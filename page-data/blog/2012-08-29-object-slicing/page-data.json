{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2012-08-29-object-slicing/","result":{"data":{"markdownRemark":{"html":"<p><span style=\"color:#000000;\">When a Derived Class object is assigned to Base class, the base class' contents in the derived object are copied to the base class leaving behind the derived class specific contents. This is referred as Object Slicing. That is, the base class object can access only the base class members. This also implies the separation of base class members from derived class members has happened.</span><br>\n<code class=\"language-text\"></code></p>\n<p style=\"padding-left:90px;\"><span style=\"color:#0000ff;\">class base</span></p>\n<p style=\"padding-left:90px;\"><span style=\"color:#0000ff;\"> {</span><br/>\n<span style=\"color:#0000ff;\"> &nbsp;&nbsp;&nbsp;&nbsp; public:</span><br/>\n<span style=\"color:#0000ff;\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i, j;</span><br/>\n<span style=\"color:#0000ff;\"> };</span><br/>\n<span style=\"color:#0000ff;\"> class derived : public base</span><br/>\n<span style=\"color:#0000ff;\"> {</span><br/>\n<span style=\"color:#0000ff;\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:</span><br/>\n<span style=\"color:#0000ff;\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int k;</span><br/>\n<span style=\"color:#0000ff;\"> };</span><br/>\n<span style=\"color:#0000ff;\"> int main()</span><br/>\n<span style=\"color:#0000ff;\"> {</span><br/>\n<span style=\"color:#0000ff;\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base b;</span><br/>\n<span style=\"color:#0000ff;\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; derived d;</span><br/>\n<span style=\"color:#0000ff;\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b=d;</span><br/>\n<span style=\"color:#0000ff;\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</span><br/>\n<span style=\"color:#0000ff;\"> }</span></p>\n<p> </p>\n<p><code class=\"language-text\"></code><br>\n<span style=\"color:#000000;\">here b contains i and j where as d contains i, j&#x26; k. On assignment only i and j of the d get copied into i and j of b. k does not get copied. on the effect object d got sliced.</span></p>\n<p><span style=\"color:#000000;\">In Inheritance, the attributes of the base class get carried to the derived class. However, we can assign a base class with the derived class without having the contents of the derived that are uncommon between then, copied to the base class. </span><br>\n<code class=\"language-text\"></code></p>\n<p style=\"padding-left:90px;\"><span style=\"color:#0000ff;\">class B</span></p>\n<p style=\"padding-left:90px;\"><span style=\"color:#0000ff;\"> {</span><br/>\n<span style=\"color:#0000ff;\"> &nbsp;&nbsp;&nbsp; public:</span><br/>\n<span style=\"color:#0000ff;\"> &nbsp;&nbsp;&nbsp; int i;</span><br/>\n<span style=\"color:#0000ff;\"> };</span></p>\n<p style=\"padding-left:90px;\"><span style=\"color:#0000ff;\">class D : public B</span><br/>\n<span style=\"color:#0000ff;\"> {</span><br/>\n<span style=\"color:#0000ff;\"> &nbsp;&nbsp;&nbsp;&nbsp; public:</span><br/>\n<span style=\"color:#0000ff;\"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int j;</span><br/>\n<span style=\"color:#0000ff;\"> };</span></p>\n<p style=\"padding-left:90px;\"><span style=\"color:#0000ff;\"> int main()</span><br/>\n<span style=\"color:#0000ff;\"> {</span><br/>\n<span style=\"color:#0000ff;\"> &nbsp;&nbsp;&nbsp;&nbsp; B B1;</span><br/>\n<span style=\"color:#0000ff;\"> &nbsp;&nbsp;&nbsp;&nbsp; D D1;</span><br/>\n<span style=\"color:#0000ff;\"> &nbsp;&nbsp;&nbsp;&nbsp; B1 = D1; //only i is copied to B1</span><br/>\n<span style=\"color:#0000ff;\"> }</span></p>\n<p><span style=\"color:#000000;\"><strong><span style=\"text-decoration:underline;\">Note:</span></strong></span></p>\n<p><code class=\"language-text\"></code><br>\n<span style=\"color:#000000;\">A better term for this case might be \"</span><strong>Partial Assignment</strong><span style=\"color:#000000;\">\".</span></p>\n<p><span style=\"color:#000000;\">Such partial assignment is not possible in Java because that language only allows object references, and assignment to a reference simply causes it to refer to a different </span><span style=\"color:#000000;\">object.</span></p>\n<p><strong>How does the compiler then call the base destructors?</strong></p>\n<p>The process of destructing an object takes more operations than those you write inside the body of the destructor. When the compiler generates the code for the destructor, it adds extra code both before and after the user defined code.</p>\n<p>Before the first line of a user defined destructor is called, the compiler injects code that will make the type of the object be that of the destructor being called. That is, right before ~derived is entered, the compiler adds code that will modify the vptr to refer to the vtable of derived, so that effectively, the runtime type of the object <em>becomes</em> derived <sup>(*)</sup>.</p>\n<p>After the last line of your user defined code, the compiler injects calls to the member destructors as well as base destructor(s). This is performed <em>disabling</em> dynamic dispatch, which means that it will no longer come all the way down to the just executed destructor. It is the equivalent of adding this->~mybase(); for each base of the object (in reverse order of declaration of the bases) at the end of the destructor.</p>\n<p>With virtual inheritance, things get a bit more complex, but overall they follow this pattern.</p>\n<p><em>EDIT</em> (forgot the <sup>(*)</sup>): <sup>(*)</sup> The standard mandates in §12/3:</p>\n<p>When a virtual function is called directly or indirectly from a constructor (including from the mem-initializer for a data member) or from a destructor, and the object to which the call applies is the object under construction or destruction, the function called is the one defined in the constructor or destructor’s own class or in one of its bases, but not a function overriding it in a class derived from the con- structor or destructor’s class, or overriding it in one of the other base classes of the most derived object.</p>\n<p>That requirement implies that the runtime type of the object is that of the class being constructed/destructed at this time, even if the original object that is being constructed/destructed is of a derived type. A simple test to verify this implementation can be:</p>\n<p>#include &#x3C;iostream><br>\nusing namespace std ;</p>\n<p>struct Base {<br>\nvirtual ~Base() { f(); }<br>\nvirtual void f() { std::cout &#x3C;&#x3C; \"Base\" &#x3C;&#x3C;endl ; }<br>\n};</p>\n<p>struct Derived : Base {<br>\nvoid f() { std::cout &#x3C;&#x3C; \"Derived\" &#x3C;&#x3C; endl; }<br>\n};</p>\n<p>int main() {<br>\nBase * p = new Derived;<br>\ndelete p;<br>\nreturn 0 ;<br>\n}</p>\n<p>Ouput:</p>\n<p>Base</p>\n<p>END</p>","excerpt":"When a Derived Class object is assigned to Base class, the base class' contents in the derived object are copied to the base class leaving behind the derived…","frontmatter":{"date":"29 August, 2012","path":"/blog/2012-08-29-object-slicing/","title":"Object Slicing"},"fields":{"readingTime":{"text":"4 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}