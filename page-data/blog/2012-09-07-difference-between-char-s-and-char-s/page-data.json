{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2012-09-07-difference-between-char-s-and-char-s/","result":{"data":{"markdownRemark":{"html":"<p>The difference here is that</p>\n<pre style=\"background-color:#c0c0c0;margin:0;width:100%;font-family:consolas, 'Courier New', courier, monospace;font-size:13px;\"><span style=\"color:#0000ff;\">char</span> *s = \"<span style=\"color:#8b0000;\">Hello world</span>\";</pre>\n<p>will place Hello world in the read-only parts of the memory and making s a pointer to that, making any writing operation on this memory illegal. While doing:</p>\n<pre style=\"background-color:#c0c0c0;margin:0;width:100%;font-family:consolas, 'Courier New', courier, monospace;font-size:13px;\"><span style=\"color:#0000ff;\">char</span> s[] = \"<span style=\"color:#8b0000;\">Hello world</span>\";</pre>\n<p>puts the literal string in read-only memory and copies the string to newly allocated memory on the stack. Making</p>\n<pre style=\"background-color:#c0c0c0;margin:0;width:100%;font-family:consolas, 'Courier New', courier, monospace;font-size:13px;\">s[0] = 'J';</pre>\n<p>legal.</p>\n<p><span style=\"text-decoration:underline;\">Note:</span></p>\n<p>The char array example does <em>not</em> necessarily place the string on the stack - if it appears at file level, it will probably be in some kind of initialised data segment instead.</p>\n<p><span style=\"font-family:Arial;font-size:medium;\">First off, in function arguments, they are exactly equivalent:</span></p>\n<pre style=\"background-color:#c0c0c0;margin:0;width:100%;font-family:consolas, 'Courier New', courier, monospace;font-size:13px;\"><span style=\"color:#0000ff;\">void</span> foo(<span style=\"color:#0000ff;\">char</span> *x);</pre>\n<pre style=\"background-color:#c0c0c0;margin:0;width:100%;font-family:consolas, 'Courier New', courier, monospace;font-size:13px;\"><span style=\"color:#0000ff;\">void</span> foo(<span style=\"color:#0000ff;\">char</span> x[]); <span style=\"color:#008000;\">// exactly the same in all respects (note! this only applies if the brackets are empty)</span></pre>\n<p><span style=\"font-family:Arial;font-size:medium;\">In other contexts, char * allocates a pointer, while char [] allocates an array. </span></p>\n<p><span style=\"font-family:Arial;font-size:medium;\">Where does the string go in the former case, you ask? The compiler secretly allocates a static anonymous array to hold the string literal. So:</span></p>\n<pre style=\"background-color:#c0c0c0;margin:0;width:100%;font-family:consolas, 'Courier New', courier, monospace;font-size:13px;\"><span style=\"color:#0000ff;\">char</span> *x = \"<span style=\"color:#8b0000;\">Foo</span>\";</pre>\n<pre style=\"background-color:#c0c0c0;margin:0;width:100%;font-family:consolas, 'Courier New', courier, monospace;font-size:13px;\"><span style=\"color:#008000;\">// is approximately equivalent to:</span></pre>\n<pre style=\"background-color:#c0c0c0;margin:0;width:100%;font-family:consolas, 'Courier New', courier, monospace;font-size:13px;\"><span style=\"color:#0000ff;\">static</span> <span style=\"color:#0000ff;\">const</span> <span style=\"color:#0000ff;\">char</span> __secret_anonymous_array[] = \"<span style=\"color:#8b0000;\">Foo</span>\";</pre>\n<pre style=\"background-color:#c0c0c0;margin:0;width:100%;font-family:consolas, 'Courier New', courier, monospace;font-size:13px;\"><span style=\"color:#0000ff;\">char</span> *x = (<span style=\"color:#0000ff;\">char</span> *) __secret_anonymous_array;</pre>\n<p><span style=\"font-family:Arial;font-size:medium;\">Note that you must not ever attempt to modify the contents of this anonymous array via this pointer; the effects are undefined (often meaning a crash):</span></p>\n<pre style=\"background-color:#c0c0c0;margin:0;width:100%;font-family:consolas, 'Courier New', courier, monospace;font-size:13px;\">x[1] = 'O'; <span style=\"color:#008000;\">// BAD. DON'T DO THIS.</span></pre>\n<p><span style=\"font-family:Arial;font-size:medium;\">Using the array syntax directly allocates it into new memory. Thus modification is safe:</span></p>\n<pre style=\"background-color:#c0c0c0;margin:0;width:100%;font-family:consolas, 'Courier New', courier, monospace;font-size:13px;\"><span style=\"color:#0000ff;\">char</span> x[] = \"<span style=\"color:#8b0000;\">Foo</span>\";</pre>\n<pre style=\"background-color:#c0c0c0;margin:0;width:100%;font-family:consolas, 'Courier New', courier, monospace;font-size:13px;\">x[1] = 'O'; <span style=\"color:#008000;\">// No problem.</span></pre>\n<p><span style=\"font-family:Arial;font-size:medium;\">However the array only lives as long as its containing scope, so if you do this in a function, don't return or leak a pointer to this array - make a copy instead with strdup() or similar. If the array is allocated in global scope, of course, no problem.</span></p>\n<p>The first one is array the other is pointer.</p>\n<p>The array declaration \"char a[6];\" requests that space for six characters be set aside, to be known by the name \"a.\" That is, there is a location named \"a\" at which six characters can sit. The pointer declaration \"char *p;\" on the other hand, requests a place which holds a pointer. The pointer is to be known by the name \"p,\" and can point to any char (or contiguous array of chars) anywhere.</p>\n<p>The statements</p>\n<pre>char a[] = \"hello\";\n\nchar *p = \"world\";</pre>\n<p>would result in data structures which could be represented like this:</p>\n<blockquote><p>&nbsp;</p><p><a href=\"/Users/Ramesh/AppData/Local/Temp/WindowsLiveWriter-429641856/supfiles1E98B828/image[2].png\"><img alt=\"image\" border=\"0\" height=\"75\" src=\"{{ site.baseurl }}/assets/image_thumb.png\" title=\"image\" width=\"244\"/></a></p></blockquote>\n<p>It is important to realize that a reference like x[3] generates different code depending on whether x is an array or a pointer. Given the declarations above, when the compiler sees the expression a[3], it emits code to start at the location \"a,\" move three past it, and fetch the character there. When it sees the expression p[3], it emits code to start at the location \"p,\" fetch the pointer value there, add three to the pointer, and finally fetch the character pointed to. In the example above, both a[3] and p[3] happen to be the character 'l', but the compiler gets there differently.</p>","excerpt":"The difference here is that will place Hello world in the read-only parts of the memory and making s a pointer to that, making any writing operation on thisâ€¦","frontmatter":{"date":"06 September, 2012","path":"/blog/2012-09-07-difference-between-char-s-and-char-s/","title":"Difference between char s[] and char *s"},"fields":{"readingTime":{"text":"4 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}