{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2013-01-27-delete-how-does-compiler-know-how-many-objects-to-delete/","result":{"data":{"markdownRemark":{"html":"<p>delete[] p</p>\n<p>The run-time system stores the number of objects, <tt>n</tt>, somewhere where it can be retrieved if you only know the pointer, <tt>p</tt>. There are two popular techniques that do this. Both these techniques are in use by commercial-grade compilers, both have tradeoffs, and neither is perfect. These techniques are:</p>\n<ul>\n<li><span style=\"color:#333333;font-family:'Helvetica Neue', Helvetica, Arial, 'Nimbus Sans L', sans-serif;font-style:normal;\">Over-allocate the array and put n just to the left of the first Fred object.</span></li>\n</ul>\n<p>new char[10] could allocates a few extra bytes, put the number of elements at the beginning, then return the pointer to the first element after that. delete[] could then look behind the pointer at the stored count</p>\n<ul>\n<li><span style=\"color:#333333;font-family:'Helvetica Neue', Helvetica, Arial, 'Nimbus Sans L', sans-serif;font-style:normal;\">Use an associative array with p as the key and n as the value.</span></li>\n</ul>\n<p>store the equivalent of std::map&#x3C;void*, size_t>, and new T[n] would create a key with the returned pointer, and a value with the count. delete[] would look up the pointer in this map</p>\n<p> </p>","excerpt":"delete[] p The run-time system stores the number of objects, n, somewhere where it can be retrieved if you only know the pointer, p. There are two popular…","frontmatter":{"date":"26 January, 2013","path":"/blog/2013-01-27-delete-how-does-compiler-know-how-many-objects-to-delete/","title":"delete[] --- How does Compiler know how many Objects to Delete"},"fields":{"readingTime":{"text":"1 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}