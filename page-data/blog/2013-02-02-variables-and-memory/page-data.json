{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2013-02-02-variables-and-memory/","result":{"data":{"markdownRemark":{"html":"<p>When a C++ program starts, 5 distinct areas of memory are created. These are:</p>\n<ul>\n<li><em>Code Space</em>: This is where the executable instructions of the program are kept.</li>\n<li><em>Registers</em>: are part of the CPU that take care of internal housekeeping. Among other things, they contain an identifier that points to the next line of code that is to be executed, and the stack pointer.</li>\n<li><em>Global Name Space</em>: contains objects allocated by the linker which will persist for the duration of the program.</li>\n<li><em>Stack</em>: contains local variables, whose persistency is defined by their scope.</li>\n<li><em>Free Store, or Heap</em> is explicitly created and destroyed by issuing <code class=\"language-text\">new</code> and <code class=\"language-text\">delete</code> commands.</li>\n</ul>\n<p>This lesson will concentrate on the differences between the last three.</p>\n<h4>The Stack</h4>\n<p>The stack is where local variables and function parameters reside. It is called a stack because it follows the last-in, first-out principle. As data is added or <em>pushed</em> to the stack, it grows, and when data is removed or <em>popped</em> it shrinks. In reality, memory addresses are not physically moved around every time data is pushed or popped from the stack, instead the <em>stack pointer</em>, which as the name implies points to the memory address at the top of the stack, moves up and down. Everything below this address is considered to be on the stack and usable, whereas everything above it is off the stack, and invalid. This is all accomplished automatically by the operating system, and as a result it is sometimes also called <em>automatic</em> memory. On the extremely rare occasions that one needs to be able to explicitly invoke this type of memory, the C++ key word <code class=\"language-text\">auto</code> can be used. Normally, one declares variables on the stack like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">void func () { \nint i; float x[100];\n\n...\n\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Variables that are declared on the stack are only valid within the scope of their declaration. That means when the function <code class=\"language-text\">func()</code> listed above returns, <code class=\"language-text\">i</code> and <code class=\"language-text\">x</code> will no longer be accessible or valid.</p>\n<p>There is another limitation to variables that are placed on the stack: the operating system only allocates a certain amount of space to the stack. As each part of a program that is being executed comes into scope, the operating system allocates the appropriate amount of memory that is required to hold all the local variables on the stack. If this is greater than the amount of memory that the OS has allowed for the total size of the stack, then the program will crash. While the maximum size of the stack can sometimes be changed by compile time parameters, it is usually fairly small, and nowhere near the total amount of RAM available on a machine.</p>\n<h4>The Global Namespace</h4>\n<p>The fact that variables on the stack disappear as soon as they go out of scope limits their usefulness. Another class of variables exist that do not have this limitation. These are global and namespace variables, static class members, and static variables in functions. Global variables are accessible throughout the program, and are declared in this manner:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">#include &amp;lt; iostream &amp;gt;\nvoid func();\n\nint i = 5;\nint j = 3;\nfloat f = 10.0;\n\nint main() {\n   int j = 7;\n\n   cout &amp;lt;&amp;lt; &quot;i in main: &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;\n   cout &amp;lt;&amp;lt; &quot;j in main: &quot; &amp;lt;&amp;lt; j &amp;lt;&amp;lt; endl;\n   cout &amp;lt;&amp;lt; &quot;global j:  &quot; &amp;lt;&amp;lt; ::j &amp;lt;&amp;lt; endl;\n\n   func();\n\n   return 0;\n\n}\n\nvoid func() {\n   float f = 20.0;\n\n   cout &amp;lt;&amp;lt; &quot;f in func: &quot; &amp;lt;&amp;lt; f &amp;lt;&amp;lt; endl;\n   cout &amp;lt;&amp;lt; &quot;global f:  &quot; &amp;lt;&amp;lt; ::f &amp;lt;&amp;lt; endl;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The output of this program will be:</p>\n<pre>i in main: 5\nj in main: 7\nglobal j:  3\nf in func: 20.0\nglobal f:  10.0</pre>\n<p>Local variables take precedence over global variables of the same name. If both are defined as shown above for the variable <code class=\"language-text\">int j</code>, then <code class=\"language-text\">j</code> refers to the local copy, whereas <code class=\"language-text\">::j</code> refers to the global copy.</p>\n<p>Despite their attraction, <strong>global variables are very dangerous, and should be avoided</strong>. The permit uncontrolled access to data, which runs counter to the object nature of C++ programming.</p>\n<p>When data is common to, or must be shared amongst all instances of a class, one can use <code class=\"language-text\">static</code> variables:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class Muon {\n public:\n   Muon(float E):Energy(E) { MuonsInEvent++; }\n   ~Muon() {MuonsInEvent--; }\n\n   static int MuonsInEvent;\n\n private:\n   float Energy;\n\n};\n\nint Muon::MuonsInEvent = 0;\n\nint main() {\n\n   Muon *muons[10];\n   int nummuons;\n\n   for (int i=0; i&amp;lt;10; i++) {\n       muons[i] = new Muon(0.);\n   }\n\n   nummuons = Muon::MuonsInEvent;   \n\n....\n\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Here the integer <code class=\"language-text\">MuonsInEvent</code> is static, and common to all instances of the <code class=\"language-text\">Muon</code> class. The declaration of <code class=\"language-text\">MuonsInEvent</code> does not define an integer, and no storage space is set aside. So the variable must be defined and initialized, as it is on the 13th line. Since it was declared <code class=\"language-text\">public</code>, it can then be accessed directly in <code class=\"language-text\">main()</code> by its class reference, and not by a reference to a specific instance of the class. If one wishes to restrict access to the static variable, as is often wise, it can be declared <code class=\"language-text\">private</code>, and then only member functions of the class can access it, just like a normal private variable.</p>\n<p>Member functions of a class can also be declared <code class=\"language-text\">static</code>. They exist not in an object, but in the scope of a class, and can thus be called without having an object of that class:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class Muon {\n public:\n   Muon(float E):Energy(E) { MuonsInEvent++; }\n   ~Muon() {MuonsInEvent--; }\n\n   static int GetNumMuons() { return MuonsInEvent; }\n\n private:\n   float Energy;\n   static int MuonsInEvent;\n\n};\n\nint Muon::MuonsInEvent = 0;\n\nint main() {\n\n   Muon *muons[10];\n   int nummuons;\n\n   for (int i=0; i&amp;lt;10; i++) {\n       muons[i] = new Muon(0.);\n   }\n\n   nummuons = Muon::GetNumMuons();   \n\n....\n\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Note that static member functions do not have a <code class=\"language-text\">this</code> pointer, and therefore cannot be declared <code class=\"language-text\">const</code>. And since member data variables are accessed in member functions using the<code class=\"language-text\">this</code> pointer, <strong>static member functions cannot access any non-static member variables</strong>.</p>\n<p>Furthermore, static variables should not be used as a pseudo-global variable. While there are certain distinct implementations where they are mandated, <strong>static variables and functions should be used with caution</strong>. If you find yourself using them frequently, there is a significant chance that your design is at fault. This is especially true for Level 3 code, as tools are instantiated at the beginning of the run, and thus their members are easily accessible at any time thereafter.</p>\n<h4>The Free Store</h4>\n<p>The main problem with local variables, is that they don't persist. As soon as a function returns, all the local variables declared within it vanish. While it is possible to get around this with global variables, this is not wise. Instead, one can make use of the <em>free store</em>, or <em>heap</em> as it is often called.</p>\n<p>Variables and objects are declared on the heap using the keyword <code class=\"language-text\">new</code>, and are referenced using pointers. <code class=\"language-text\">new</code> will attempt to allocate the requested memory on the heap, and will throw a <code class=\"language-text\">bad_alloc</code> exception if it can not. While running out of memory is not usually a problem, when dealing with large programs it is often wise to check:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">int *pI;\n\ntry { pI = new int; }\ncatch(std::bad_alloc) {\n    cout &amp;lt;&amp;lt; &quot;ERROR: no more memory\\n&quot;;\n    return(1);\n}\n\n.....\n\ndelete pI;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Once you're done with something declared on the heap, it must be explicitly freed using the keyword <code class=\"language-text\">delete</code>. If this is not done, and the pointer is reassigned, a memory leak occurs. The original memory becomes unavailable, and cannot be accessed. If this is done many times, then eventually all the available memory will be gobbled up, and your program will crash.</p>\n<p>The heap is where the vast majority of your variables should be declared. This is because the heap is far larger than the stack, and once something is placed there, it won't disappear until you tell it to, avoiding the use of those nasty global variables.</p>\n<p>Note that most memory managers are greedy: even when memory is properly freed with <code class=\"language-text\">delete</code>, it is not really returned to the OS. That is, if your program allocates 1000 bytes, the size of the program in memory will grow to about that size. If you then free 1000 bytes, the program will not release the memory back to the OS - it will still look like it owns 1000 bytes of system memory. However you will have to then reallocate 1001 bytes of memory before the program size will grow again. Only when the program ends will this memory be returned to the system.</p>\n<p>An interesting note: on the SGI, the preceding paragraph is correct. However, it seems that the memory manager in Linux is more intelligent. When space on the heap is deleted in Linux, the allocated memory is returned to the operating system. Depending on the application, this can be a good or a bad thing.</p>\n<p>When checking for an out of memory condition, one can get a little fancier, and make use of the <code class=\"language-text\">new</code> function <code class=\"language-text\">set_new_handler()</code> which specifies what <code class=\"language-text\">new</code> will do when it fails. You still need to <code class=\"language-text\">try/catch</code> the exception though:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">void out_of_store() {\n   cerr &amp;lt;&amp;lt; &quot;ERROR: operator new failed: out of store\\n&quot;;\n   throw std::bad_alloc();\n}\n\nint main() {\n\n   ....\n\n   int *pI;\n   set_new_handler(out_of_store);\n\n   try { pI = new int; }\n   catch(std::bad_alloc) {\n      return(1);\n   }\n\n   ....\n\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>If you want your code to follow the standard C syntax and return a null pointer when <code class=\"language-text\">new</code> fails, then the form <code class=\"language-text\">new(nothrow)</code> must be used:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">int *pI;\n\npI = new(nothrow) int;\nif (pI == NULL) {\n   cout &amp;lt;&amp;lt; &quot;ERROR: no more memory\\n&quot;;\n   return(1);\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Note:<br>\nVariables are usually stored in RAM. This is either on the heap (e.g. all global variables will usually go there) or on the stack (all variables declared within a method/function usually go there). Stack and Heap are both RAM, just different locations. Pointers have different rules. The pointer to something (a memory block, an object, etc.) itself usually follows the rules of above (a pointer declared within a function is stored on the stack), but the data it points to (the memory block itself or the object you created with new) is stored on the heap. You can create pointers pointing to the stack (e.g. \"int a = 10; int * b = &#x26;a;\", b points to a and a is stored on the stack), but memory allocation using malloc or new counts towards heap memory.</p>\n<p><img src=\"%7B%7B%20site.baseurl%20%7D%7D/assets/linuxFlexibleAddressSpaceLayout.png\" alt=\"Flexible Process Address Space Layout In Linux\"></p>\n<pre><img alt=\"Classic Process Address Space Layout In Linux\" src=\"{{ site.baseurl }}/assets/linuxClassicAddressSpaceLayout.png\"/>\n\n<a href=\"http://www.pmzone.org/chapter04.html#top\">http://www.pmzone.org/chapter04.html#top\n</a><a href=\"http://www.inf.udec.cl/~leo/teoX.pdf\">http://www.inf.udec.cl/~leo/teoX.pdf</a>\n</pre>","excerpt":"When a C++ program starts, 5 distinct areas of memory are created. These are: Code Space: This is where the executable instructions of the program are kept…","frontmatter":{"date":"02 February, 2013","path":"/blog/2013-02-02-variables-and-memory/","title":"Variables and Memory"},"fields":{"readingTime":{"text":"9 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}