{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2013-02-27-non-virtual-interface-design-pattern-question/","result":{"data":{"markdownRemark":{"html":"<p>When design interface, someone recommend to use non-virtual interface pattern.</p>\n<p>The essence of the non-virtual interface pattern is that you have <strong>private virtual</strong> functions, which are called by <strong>public non-virtual</strong> functions (the non-virtual interface).</p>\n<p>The advantage of this is that the base class has more control over its behaviour than it would if derived classes were able to override any part of its interface. In other words, the base class (the interface) can provide more guarantees about the functionality it provides.</p>\n<p>As a simple example, consider the good old animal class with a couple of typical derived classes:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class Animal\n{\npublic:\n    virtual void speak() const = 0;\n};\n\nclass Dog : public Animal\n{\npublic:\n    void speak() const { std::cout &amp;lt;&amp;lt; &quot;Woof!&quot; &amp;lt;&amp;lt; std::endl; }\n};\n\nclass Cat : public Animal\n{\npublic:\n    void speak() const { std::cout &amp;lt;&amp;lt; &quot;Meow!&quot; &amp;lt;&amp;lt; std::endl; }\n};</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This uses the usual public virtual interface that we're used to, but it has a couple of problems:</p>\n<ol>\n<li>Each derived animal is repeating code -- the only part that changes is the string, yet each derived class needs the whole <code class=\"language-text\">std::cout &amp;lt;&amp;lt; ... &amp;lt;&amp;lt; std::endl;</code> boilerplate code.</li>\n<li>The base class can't make guarantees about what <code class=\"language-text\">speak()</code> does. A derived class may forget the new line, or write it to <code class=\"language-text\">cerr</code> or anything for that matter.</li>\n</ol>\n<p>To fix this, you can use a non-virtual interface that is supplemented by a private virtual function that allows polymorphic behaviour:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class Animal\n{\npublic:\n   void speak() const { std::cout &amp;lt;&amp;lt; getSound() &amp;lt;&amp;lt; std::endl; }\nprivate:\n   virtual std::string getSound() const = 0;\n};\n\nclass Dog : public Animal\n{\nprivate:\n   std::string getSound() const { return &quot;Woof!&quot;; }\n};\n\nclass Cat : public Animal\n{\nprivate:\n   std::string getSound() const { return &quot;Meow!&quot;; }\n};</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Now the base class can guarantee that it will write out to <code class=\"language-text\">std::cout</code> and end with a new line. It also makes maintenance easier as derived classes don't need to repeat that code.</p>\n<p>Herb Sutter wrote <a href=\"http://www.gotw.ca/publications/mill18.htm\" rel=\"nofollow\">a good article on non-virtual interfaces</a> that I would recommend checking out.</p>","excerpt":"When design interface, someone recommend to use non-virtual interface pattern. The essence of the non-virtual interface pattern is that you have private virtual…","frontmatter":{"date":"27 February, 2013","path":"/blog/2013-02-27-non-virtual-interface-design-pattern-question/","title":"Non-virtual interface design pattern question"},"fields":{"readingTime":{"text":"2 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}