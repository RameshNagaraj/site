{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2013-05-02-delete-an-entry-in-stl-containers/","result":{"data":{"markdownRemark":{"html":"<p>For Sequence Containers:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">for(MyMap::iterator it = mymap.begin(); it!=mymap.end(); ) {\n  if(mycondition(it))\n    it = mymap.erase(it);\n  else\n    it++;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This will work for sequence containers like std::vector, but not for associative containers like std::map. The difference is that in sequence containers erase() returns an iterator to the next element, whereas in associative containers it returns void.</p>\n<p>For Associative Containers:</p>\n<p>one approach:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">std::map&amp;lt;K, V&amp;gt;::iterator itr = myMap.begin();\nwhile (itr != myMap.end()) {\n    if (ShouldDelete(*itr)) {\n       std::map&amp;lt;K, V&amp;gt;::iterator toErase = itr;\n       ++itr;\n       myMap.erase(toErase);\n    } else {\n       ++itr;\n    }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The idea is to walk the iterator forward from the start of the container to the end, checking at each step whether the current key/value pair should be deleted. If so, a copy of the iterator is made and the iterator is advanced to the next step (to avoid iterator invalidation), then the copied iterator is removed from the container. Otherwise, the iterator is advanced as usual.</p>\n<p>Another common approach is seen here:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">std::map&amp;lt;K, V&amp;gt;::iterator itr = myMap.begin();\nwhile (itr != myMap.end()) {\n    if (ShouldDelete(*itr)) {\n       myMap.erase(itr++); //Advance before Itr becomes Invalid\n    } else {\n       ++itr;\n    }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This uses the fact that <code class=\"language-text\">itr++</code> returns the value that the old iterator used to have as a side-effect of advancing it forward a step.</p>\n<p>A variation of Mark Ransom algorithm but without the need for a temporary.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">for(Actions::iterator it = _actions.begin();it != _actions.end();)\n{\n    if (expired(*it))\n    {\n        bar(*it);\n        _actions.erase(it++);  // Note the post increment here.\n                               // This increments &#39;it&#39; and returns a copy of\n                               // the original &#39;it&#39; to be used by erase()\n    }\n    else\n    {\n        ++it;  // Use Pre-Increment here as it is more effecient\n               // Because no copy of it is required.\n    }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>You can post-increment the iterator while passing it as argument to erase:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">myMap.erase(itr++)</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>This way, the element that was pointed by <code class=\"language-text\">itr</code> before the erase is deleted, and the iterator is incremented to point to the next element in the map. If you're doing this in a loop, beware not to increment the iterator twice.</p>\n<p>B<a href=\"http://stackoverflow.com/questions/5460678/whats-the-best-way-to-delete-an-entry-mapint-a\">est way to delete an entry map&#x3C;int, A*></a></p>\n<p>Delete object first, then remove from map. Otherwise you're just introducing a pointless intermediate variable for storing the pointer. As long as you're singlethreaded, or have proper locking in a multithreaded scenario, the two methods are for all practical purposes equivalent.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">map&amp;lt;int, A *&amp;gt;::iterator it = mymap.find(1);\nif (it != mymap.end()) {\n  delete it-&amp;gt;second;\n  mymap.erase(it);\n} </code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>End</p>","excerpt":"For Sequence Containers: This will work for sequence containers like std::vector, but not for associative containers like std::map. The difference is that in…","frontmatter":{"date":"02 May, 2013","path":"/blog/2013-05-02-delete-an-entry-in-stl-containers/","title":"Delete An Entry in STL containers"},"fields":{"readingTime":{"text":"2 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}