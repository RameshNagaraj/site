{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2013-08-08-virtual-destructor/","result":{"data":{"markdownRemark":{"html":"<p>If the destructor in the base class is not made virtual, then an object that might have been declared of type base class and instance of child class would simply call the base class destructor without calling the derived class destructor.</p>\n<p>Hence, by making the destructor in the base class virtual, we ensure that the derived class destructor gets called before the base class destructor.</p>\n<p>class a<br>\n{<br>\npublic:<br>\na(){printf(\"\\nBase Constructor\\n\");}<br>\n~a(){printf(\"\\nBase Destructor\\n\");}<br>\n};</p>\n<p>class b : public a<br>\n{<br>\npublic:<br>\nb(){printf(\"\\nDerived Constructor\\n\");}<br>\n~b(){printf(\"\\nDerived Destructor\\n\");}<br>\n};<br>\nint main()<br>\n{<br>\na* obj=new b;<br>\ndelete obj;<br>\nreturn 0;<br>\n}</p>\n<p>Output:<br>\nBase Constructor<br>\nDerived Constructor<br>\nBase Destructor</p>\n<p>By Changing<br>\n~a(){printf(\"\\nBase Destructor\\n\");}<br>\nto<br>\nvirtual ~a(){printf(\"\\nBase Destructor\\n\");}</p>\n<p>Output:<br>\nBase Constructor<br>\nDerived Constructor<br>\nDerived Destructor<br>\nBase Destructor.</p>\n<p> </p>\n<p><strong>Virtual destructors:</strong></p>\n<p>The explicit destroying of object with the use of delete operator to a base class pointer to the object is performed by the destructor of the base-class is invoked on that object.</p>\n<p>The above process can be simplified by declaring a virtual base class destructor.<br>\nAll the derived class destructors are made virtual in spite of having the same name as the base class destructor. In case the object in the hierarchy is destroyed explicitly by using delete operator to the base class pointer to a derived object, the appropriate destructor will be invoked.</p>\n<p><strong>Virtual constructor:</strong></p>\n<p>A constructor of a class can not be virtual and if causes a syntax error.</p>\n<p>Disclaimer: The standard does not mandate any particular way of performing this operations, it only mandates what the behavior of the operations at a higher level are. These are implementation details that are common to various implementations, but not mandated by the standard.</p>\n<p><strong>How does the compiler dispatch to the final overrider?</strong></p>\n<p>The first answer is the simple one, the same dynamic dispatch mechanism that is used for other<code class=\"language-text\">virtual</code> functions is used for destructors. To refresh it, each object stores a pointer (<code class=\"language-text\">vptr</code>) to each of its <code class=\"language-text\">vtable</code>s (in the event of multiple inheritance there can be more than one), when the compiler sees a call to any virtual function, it follows the <code class=\"language-text\">vptr</code> of the static type of the pointer to find the<code class=\"language-text\">vtable</code> and then uses the pointer in that table to forward the call. In most cases the call can be directly dispatched, in others (multiple inheritance) it calls some intermediate code (<em>thunk</em>) that fixes the <code class=\"language-text\">this</code>pointer to refer to the type of the <em>final overrider</em> for that function.</p>\n<p><strong>How does the compiler then call the base destructors?</strong></p>\n<p>The process of destructing an object takes more operations than those you write inside the body of the destructor. When the compiler generates the code for the destructor, it adds extra code both before and after the user defined code.</p>\n<p>Before the first line of a user defined destructor is called, the compiler injects code that will make the type of the object be that of the destructor being called. That is, right before <code class=\"language-text\">~derived</code> is entered, the compiler adds code that will modify the <code class=\"language-text\">vptr</code> to refer to the <code class=\"language-text\">vtable</code> of <code class=\"language-text\">derived</code>, so that effectively, the runtime type of the object <em>becomes</em> <code class=\"language-text\">derived</code> (*).</p>\n<p>After the last line of your user defined code, the compiler injects calls to the member destructors as well as base destructor(s). This is performed <em>disabling</em> dynamic dispatch, which means that it will no longer come all the way down to the just executed destructor. It is the equivalent of adding <code class=\"language-text\">this-&amp;gt;~mybase();</code> for each base of the object (in reverse order of declaration of the bases) at the end of the destructor.</p>\n<p>With virtual inheritance, things get a bit more complex, but overall they follow this pattern.</p>\n<p><em>EDIT</em> (forgot the (*)): (*) The standard mandates in §12/3:</p>\n<blockquote>\n<p>\nWhen a virtual function is called directly or indirectly from a constructor (including from the mem-initializer for a data member) or from a destructor, and the object to which the call applies is the object under construction or destruction, the function called is the one defined in the constructor or destructor’s own class or in one of its bases, but not a function overriding it in a class derived from the con- structor or destructor’s class, or overriding it in one of the other base classes of the most derived object.</p>\n</blockquote>\n<p>That requirement implies that the runtime type of the object is that of the class being constructed/destructed at this time, even if the original object that is being constructed/destructed is of a derived type. A simple test to verify this implementation can be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">struct base {\n   virtual ~base() { f(); }\n   virtual void f() { std::cout &amp;lt;&amp;lt; &quot;base&quot;; }\n};\nstruct derived : base {\n   void f() { std::cout &amp;lt;&amp;lt; &quot;derived&quot;; }\n};\nint main() {\n   base * p = new derived;\n   delete p;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>END</p>","excerpt":"If the destructor in the base class is not made virtual, then an object that might have been declared of type base class and instance of child class would…","frontmatter":{"date":"08 August, 2013","path":"/blog/2013-08-08-virtual-destructor/","title":"Virtual Destructor"},"fields":{"readingTime":{"text":"4 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}