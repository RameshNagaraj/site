{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2013-09-15-virtual-constructor/","result":{"data":{"markdownRemark":{"html":"<p>To implement virtual functions, C++ uses a special form of late binding known as the virtual table. The <strong>virtual table</strong> is a lookup table of functions used to resolve function calls in a dynamic/late binding manner. The virtual table sometimes goes by other names, such as “vtable”, “virtual function table”, “virtual method table”, or “dispatch table”.</p>\n<p>Because knowing how the virtual table works is not necessary to use virtual functions, this section can be considered optional reading.</p>\n<p>The virtual table is actually quite simple, though it’s a little complex to describe in words. First, every class that uses virtual functions (or is derived from a class that uses virtual functions) is given it’s own virtual table. This table is simply a static array that the compiler sets up at compile time. A virtual table contains one entry for each virtual function that can be called by objects of the class. Each entry in this table is simply a function pointer that points to the most-derived function accessible by that class.</p>\n<p>Second, the compiler also adds a hidden pointer to the base class, which we will call *__vptr. *__vptr is set (automatically) when a class instance is created so that it points to the virtual table for that class. Unlike the *this pointer, which is actually a function parameter used by the compiler to resolve self-references, *__vptr is a real pointer. Consequently, it makes each class object allocated bigger by the size of one pointer. It also means that *__vptr is inherited by derived classes, which is important.</p>\n<p>By now, you’re probably confused as to how these things all fit together, so let’s take a look at a simple example:</p>\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"996\">\n<tbody>\n<tr>\n<td>12</td></tr></tbody></table>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>13</p>\n<p>14</p>\n<p>15</p>\n<p>16</p>\n<p>17</p>\n<p>18</p>\n<td width=\"951\">class Base{</td>\n<p>public:</p>\n<p>virtual void function1() {};</p>\n<p>virtual void function2() {};</p>\n<p>};</p>\n<p>class D1: public Base</p>\n<p>{</p>\n<p>public:</p>\n<p>virtual void function1() {};</p>\n<p>};</p>\n<p>class D2: public Base</p>\n<p>{</p>\n<p>public:</p>\n<p>virtual void function2() {};</p>\n<p>};</p>\n<p>Because there are 3 classes here, the compiler will set up 3 virtual tables: one for Base, one for D1, and one for D2.</p>\n<p>The compiler also adds a hidden pointer to the most base class that uses virtual functions. Although the compiler does this automatically, we’ll put it in the next example just to show where it’s added:</p>\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"996\">\n<tbody>\n<tr>\n<td>12</td></tr></tbody></table>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>13</p>\n<p>14</p>\n<p>15</p>\n<p>16</p>\n<p>17</p>\n<p>18</p>\n<p>19</p>\n<td width=\"951\">class Base{</td>\n<p>public:</p>\n<p>FunctionPointer *__vptr;</p>\n<p>virtual void function1() {};</p>\n<p>virtual void function2() {};</p>\n<p>};</p>\n<p>class D1: public Base</p>\n<p>{</p>\n<p>public:</p>\n<p>virtual void function1() {};</p>\n<p>};</p>\n<p>class D2: public Base</p>\n<p>{</p>\n<p>public:</p>\n<p>virtual void function2() {};</p>\n<p>};</p>\n<p>When a class object is created, *__vptr is set to point to the virtual table for that class. For example, when a object of type Base is created, *__vptr is set to point to the virtual table for Base. When objects of type D1 or D2 are constructed, *__vptr is set to point to the virtual table for D1 or D2 respectively.</p>\n<p>Now, let’s talk about how these virtual tables are filled out. Because there are only two virtual functions here, each virtual table will have two entries (one for function1(), and one for function2()). Remember that when these virtual tables are filled out, each entry is filled out with the most-derived function an object of that class type can call.</p>\n<p>Base’s virtual table is simple. An object of type Base can only access the members of Base. Base has no access to D1 or D2 functions. Consequently, the entry for function1 points to Base::function1(), and the entry for function2 points to Base::function2().</p>\n<p>D1′s virtual table is slightly more complex. An object of type D1 can access members of both D1 and Base. However, D1 has overridden function1(), making D1::function1() more derived than Base::function1(). Consequently, the entry for function1 points to D1::function1(). D1 hasn’t overridden function2(), so the entry for function2 will point to Base::function2().</p>\n<p>D2′s virtual table is similar to D1, except the entry for function1 points to Base::function1(), and the entry for function2 points to D2::function2().</p>\n<p>Here’s a picture of this graphically:</p>\n<p>Although this diagram is kind of crazy looking, it’s really quite simple: the *__vptr in each class points to the virtual table for that class. The entries in the virtual table point to the most-derived version of the function objects of that class are allowed to call.</p>\n<p>So consider what happens when we create an object of type D1:</p>\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"996\">\n<tbody>\n<tr>\n<td>12</td></tr></tbody></table>\n<p>3</p>\n<p>4</p>\n<td width=\"960\">int main(){</td>\n<p>D1 cClass;</p>\n<p>}</p>\n<p>Because cClass is a D1 object, cClass has it’s *__vptr set to the D1 virtual table.</p>\n<p>Now, let’s set a base pointer to D1:</p>\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"996\">\n<tbody>\n<tr>\n<td>12</td></tr></tbody></table>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<td width=\"960\">int main(){</td>\n<p>D1 cClass;</p>\n<p>Base *pClass = &#x26;cClass;</p>\n<p>}</p>\n<p>Note that because pClass is a base pointer, it only points to the Base portion of cClass. However, also note that *__vptr is in the Base portion of the class, so pClass has access to this pointer. Finally, note that pClass->__vptr points to the D1 virtual table! Consequently, even though pClass is of type Base, it still has access to D1′s virtual table.</p>\n<p>So what happens when we try to call pClass->function1()?</p>\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"996\">\n<tbody>\n<tr>\n<td>12</td></tr></tbody></table>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<td width=\"960\">int main(){</td>\n<p>D1 cClass;</p>\n<p>Base *pClass = &#x26;cClass;</p>\n<p>pClass->function1();</p>\n<p>}</p>\n<p>First, the program recognizes that function1() is a virtual function. Second, uses pClass->__vptr to get to D1′s virtual table. Third, it looks up which version of function1() to call in D1′s virtual table. This has been set to D1::function1(). Therefore, pClass->function1() resolves to D1::function1()!</p>\n<p>Now, you might be saying, “But what if Base really pointed to a Base object instead of a D1 object. Would it still call D1::function1()?”. The answer is no.</p>\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"996\">\n<tbody>\n<tr>\n<td>12</td></tr></tbody></table>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<td width=\"960\">int main(){</td>\n<p>Base cClass;</p>\n<p>Base *pClass = &#x26;cClass;</p>\n<p>pClass->function1();</p>\n<p>}</p>\n<p>In this case, when cClass is created, __vptr points to Base’s virtual table, not D1′s virtual table. Consequently, pClass->__vptr will also be pointing to Base’s virtual table. Base’s virtual table entry for function1() points to Base::function1(). Thus, pClass->function1() resolves to Base::function1(), which is the most-derived version of function1() that a Base object should be able to call.</p>\n<p>By using these tables, the compiler and program are able to ensure function calls resolve to the appropriate virtual function, even if you’re only using a pointer or reference to a base class!</p>\n<p>Calling a virtual function is slower than calling a non-virtual function for a couple of reasons: First, we have to use the *__vptr to get to the appropriate virtual table. Second, we have to index the virtual table to find the correct function to call. Only then can we call the function. As a result, we have to do 3 operations to find the function to call, as opposed to 2 operations for a normal indirect function call, or one operation for a direct function call. However, with modern computers, this added time is usually fairly insignificant.</p>\n<p>What happens in the below code:</p>\n<p>class Base</p>\n<p>{</p>\n<p>public:</p>\n<p>void func() {</p>\n<p>cout &#x3C;&#x3C; \"Base Class\" &#x3C;&#x3C; endl ;</p>\n<p>}</p>\n<p>} ;</p>\n<p>class D1: public Base</p>\n<p>{</p>\n<p>public:</p>\n<p>virtual void func() {</p>\n<p>cout &#x3C;&#x3C; \"D1 Class\" &#x3C;&#x3C; endl ;</p>\n<p>}</p>\n<p>} ;</p>\n<p>int main ()</p>\n<p>{</p>\n<p>Base * p = new D2() ;</p>\n<p>p->func() ;</p>\n<p>}</p>\n<p>Will the base func() be called or the D1 func() will. It will be Base.func() will be called.</p>\n<p>the appropriate method to be called is decided by <em>fetching</em> the <code class=\"language-text\">vpt</code>, <em>fetching</em> the address of the appropriate method and then <em>calling</em> the appropiate member function.<br>\nThus dynamic dispatch is essentially a <code class=\"language-text\">fetch-fetch-call</code> instead of a normal <code class=\"language-text\">call</code> in case of static binding.</p>\n<p><strong><span style=\"text-decoration:underline;\">_vptr :</span></strong></p>\n<p>This vtable pointer or _vptr, is a hidden pointer added by the Compiler to the base class. And this pointer is pointing to the virtual table of that particular class.</p>\n<p>This _vptr is inherited to all the derived classes.</p>\n<p>Each object of a class with virtual functions transparently stores this _vptr.</p>\n<p>Call to a virtual function by an object is resolved by following this hidden _vptr.</p>\n<p>Here, I will explain what happens when you use the “virtual” keyword in C++.</p>\n<p>This post will cover the following topics:</p>\n<ul>\n<li><strong>_virtual___</strong> _<strong>_keyword</strong></li>\n<li><strong>_vtable___</strong> _<strong>_(___</strong>virtual function table<strong>_</strong> _<strong>_or__</strong> <strong>_</strong>virtual method table<strong>_</strong>) and_<strong>_ ___</strong>vptr___</li>\n<li><strong>_this___</strong> _<strong>_pointer and virtual functions</strong></li>\n</ul>\n<p>I will use many code examples, so don’t worry if you don’t understand something, look at the code example and it would be ok :)</p>\n<h4>Virtual keyword</h4>\n<p>When you use a pointer to a base class that was instantiated from a derived class, you can use the <em>virtual</em>keyword to call functions from the real instance.</p>\n<p><em>#include &#x3C;iostream></em></p>\n<p>class Human<br>\n<em>/* ^ Human is the base class */</em><br>\n{<br>\npublic:<br>\nvirtual ~Human() {}<br>\nvoid sayHello() const { std::cout &#x3C;&#x3C; \"Hello, I'm a Human!\" &#x3C;&#x3C; std::endl; }<br>\nvirtual void talk() const { std::cout &#x3C;&#x3C; \"Hey, how are you?\" &#x3C;&#x3C; std::endl; }<br>\n};</p>\n<p>class Sprinter : public Human<br>\n<em>/* ^ Sprinter is the derived class */</em><br>\n{<br>\npublic:<br>\nvirtual ~Sprinter() {}<br>\n<em>/* ^ Not mandatory here, the compiler will create a default virtual</em><br>\n<em>      destructor because we inherit from Human that already defines a virtual destructor */</em></p>\n<p>void sayHello() const { std::cout &#x3C;&#x3C; \"Hi, I'm a Sprinter!\" &#x3C;&#x3C; std::endl; }<br>\nvirtual void talk() const { std::cout &#x3C;&#x3C; \"Do you like to run?\" &#x3C;&#x3C; std::endl; }<br>\n};</p>\n<p>int main()<br>\n{<br>\nHuman* fakeHuman = new Sprinter();<br>\n<em>/* ^ implicit static\\</em>cast from Sprinter* to Human* */_<br>\nHuman* human = new Human();</p>\n<p>fakeHuman->sayHello();<br>\n<em>/* ^ non-virtual function: static call to Human::sayHello()</em><br>\n<em>    output: Hello, I'm a Human! */</em><br>\nfakeHuman->talk();<br>\n<em>/* ^ virtual function: dynamic call to Sprinter::talk()</em><br>\n<em>    output: Do you like to run? */</em></p>\n<p>human->sayHello();<br>\n<em>/* ^ non-virtual function: static call to Human::sayHello()</em><br>\n<em>    output: Hello, I'm a Human! */</em><br>\nhuman->talk();<br>\n<em>/* ^ virtual function: dynamic call to Human::talk()</em><br>\n<em>    output: Hey, how are you? */</em></p>\n<p>delete fakeHuman;<br>\n<em>/* ^ thanks to the virtual destructor, it will be cleaned by calling Sprinter::~Sprinter() */</em><br>\ndelete human;<br>\n<em>/* ^ Human::~Human() is called here */</em></p>\n<p>return 0;<br>\n}</p>\n<p>Ok, we understand how to use the virtual keyword, but how the compiler manages to call the correct function?!</p>\n<h4>vtable and vptr</h4>\n<p>A <em>virtual function table</em> is like a static array that contains pointers to the (virtual) functions of a class.<br>\nEach class having at least one virtual function will get its own <em>vtable</em>.</p>\n<p>When one of these classes is instantiated, it gets an extra variable member (called <em>vptr</em>) that will contains a pointer to its <em>vtable</em>.</p>\n<p>Here’s what the <em>vtables</em> might look like:</p>\n<p>You have to know that when you compile a C++ code, the class functions are transformed into regular functions having an extra parameter: a pointer to the instance of the class, named “this” (yes, that’s where the “this” pointer comes from).</p>\n<p>So, a class function void Human::talk(); could be transformed to a C function like void_human_talk(Human* this); (you can Google <em>C++ name mangling</em> if you are interested to how compilers name symbols after C++ function names).</p>\n<p>To simplify, let’s use a <em>FuncPtr</em> type as a basic pointer to function: typedef void (*FuncPtr)(void*this);</p>\n<p>The Human <em>vtable</em> might be:</p>\n<p>static const FuncPtr _vtable_Human[] =<br>\n{<br>\n&#x26;_human_destructor,<br>\n&#x26;_human_talk<br>\n};</p>\n<p>The compiler just has to add an extra variable member to these classes: private: FuncPtr* _vptr;<br>\nThen initialize it in the constructor of these classes.<br>\nIn the constructor of <em>Human</em>: this->_vptr = &#x26;_vtable_Human;<br>\nIn the constructor of <em>Sprinter</em>: this->_vptr = &#x26;_vtable_Sprinter;</p>\n<p>When you call a virtual function, the compiler just has to look at the <em>vtable</em> to call the correct function.</p>\n<p>When you write:</p>\n<p>Human* human = new Sprinter();</p>\n<p>human->talk();</p>\n<p>A compiler might generate this code:</p>\n<p>Human* human = new Sprinter();<br>\n<em>/* ^ the constructor of Sprinter will initialize the \\</em>vptr attribute. */_</p>\n<p>FuncPtr talkPtr = human->_vptr[1];<br>\n<em>/* ^ [0]: destructor, [1]: talk */</em><br>\n(*talkPtr)(human);<br>\n<em>/* ^ Call to the correct function! Here, \"human\" is the \"this\" pointer.</em><br>\n<em>      It's sometimes a little bit more complicated to get a correct</em><br>\n<em>      \"this\" pointer, more on that bellow. */</em></p>\n<p>For your information, you can call a specific implementation of a class function by explicitly naming it:</p>\n<p>Human* human = new Sprinter();</p>\n<p>human->Human::talk();<br>\n<em>/* ^ Will NOT use the vtable, and will directly call \"talk\"</em><br>\n<em>    implementation of the Human class */</em></p>\n<h4><em>this</em> pointer and virtual functions</h4>\n<p>Sometimes, the compiler has to do a little bit of arithmetic to pass the correct <em>this</em> pointer to a virtual function.</p>\n<p>Imagine a class <em>Centaur</em> that inherits from both <em>Human</em> and <em>Horse</em>:</p>\n<p>Here is a possible memory representation of the <em>Centaur</em> class (note: in this example, the compiler optimizes the memory by using the same <em>vptr</em> attribute for both the <em>Human</em> and <em>Centaur</em> classes):</p>\n<p>So, what happens if we delete an instance of <em>Centaur</em> through a pointer to <em>Human</em>?<br>\nAs the data for a <em>Human</em> and a <em>Centaur</em> starts at the same position in memory, no special operations are needed. The <em>this</em> pointer is the same for both classes.</p>\n<p>But what happens when we use an instance of <em>Centaur</em> through a pointer to <em>Horse</em>?<br>\nWell… the static cast from a <em>Centaur</em> pointer to a <em>Horse</em> pointer will move the data pointer from some bytes (from the <em>Centaur</em> data to the <em>Horse</em> data).</p>\n<p>Centaur* centaur = new Centaur();<br>\nHuman* human = static_cast&#x3C;Human*>(centaur);<br>\n<em>/* ^ Internally: human = ((void*)centaur) + 0; // &#x3C;= same pointer ! */</em><br>\nHorse* horse = static_cast&#x3C;Horse*>(centaur);<br>\n<em>/* ^ Internally: horse = ((void*)centaur) + sizeof(Human); // &#x3C;= different pointer ! */</em></p>\n<p>So, when you delete the “horse” pointer that is an instance of <em>Centaur</em>, how the compiler passes the correct<em>this</em> pointer?</p>\n<p>A way to do that (the g++ way!) is to use a “wrapper” that will modify the <em>this</em> pointer then call the correct function.</p>\n<p>void _destructor_horse_fromCentaur(Horse* this)<br>\n{<br>\nCentaur* centaur = static_cast&#x3C;Centaur*>(this);<br>\n<em>/* ^ Internally: centaur = ((void*)this) - sizeof(Human); */</em></p>\n<p>_destructor_centaur(centaur);<br>\n<em>/* ^ Call to Centaur::~Centaur() then operator delete(centaur) to free the memory. */</em><br>\n}</p>\n<p>The <em>vtable</em> of <em>Centaur</em> will use the <em>\\</em>destructor_centaur<em> function as destructor.<br>\nWhile the </em>vtable<em> of </em>Horse<em> instantiated from a </em>Centaur<em> will use the </em>_destructor_horse_fromCentaur_ function as destructor.</p>\n<p>I hope this explanation helped you to understand how the “magic” of C++ really works!<br>\nPlease tell me if I made some mistakes or if something is unclear. Thank you!</p>\n<p> <br>\n<img src=\"%7B%7B%20site.baseurl%20%7D%7D/assets/cJQqM.png\" alt=\"enter image description here\"></p>\n<p>The runtime class of the object is a property of the object itself. In effect, <code class=\"language-text\">vptr</code> represents the runtime class, and therefore can't be <code class=\"language-text\">static</code>. What it points to, however, can be shared by all instances of the same runtime class.</p>\n<p>The whole point of the <code class=\"language-text\">vptr</code> is because you don't know exactly which class an object has at runtime. If you knew that, then the virtual function call would be unnecessary. That is, in fact, what happens when you're not using virtual functions. But with virtual functions, if I have</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class Sub : Parent {};</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>and a value of type <code class=\"language-text\">Parent*</code>, I don't know at runtime if this is really an object of type <code class=\"language-text\">Parent</code> or one of type <code class=\"language-text\">Sub</code>. The vptr lets me figure that out.</p>\n<p> </p>\n<p>END</p>","excerpt":"To implement virtual functions, C++ uses a special form of late binding known as the virtual table. The virtual table is a lookup table of functions used to…","frontmatter":{"date":"15 September, 2013","path":"/blog/2013-09-15-virtual-constructor/","title":"Virtual Constructor"},"fields":{"readingTime":{"text":"12 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}