{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2013-09-16-string-permutations-using-recursion/","result":{"data":{"markdownRemark":{"html":"<p>Problem: Write the code for producing/printing permutations of the characters in a string. For example: If \"abc\" is the input string, output permutations should be \"abc\", \"bac\", \"bca\", \"acb\", \"cab\", \"cba\".<br>\nSolution: There are at least 2 approaches to solving this problem. Even though both approaches use recursion, there is a subtle difference between the two. The second approach uses more number of recursive calls than the first and my rough analysis has shown that run time of both approaches is almost same. The first approach would be preferable given that the there are only n recursive calls compared to n! recursive calls of the second approach. Approach 1:<br>\nPseudo Code:</p>\n<pre>1. Set index = 0 to point to the 1st character in the input string\n    2. If index = n-1 return last character (n is length of input string)\n    3. Get Permutations of string starting at index + 1 \n    4. For each permutation in the list from step 3\n         a. Insert input[index] character in all possible positions of each\n            permutation.\n\nExample:\n input = \"abc\"\n get permutations for \"bc\": \"bc\" and \"cb\"\n insert \"a\" in all positions of both \"bc\" and \"cb\": \n          \"a\" * \"bc\": \"abc\", \"bac\", \"bca\"\n          \"a\" * \"cb\": \"acb\", \"cab\", \"cba\"</pre>\n<p>Code (C#):</p>\n<pre>List&lt;string&gt; Permute(string, str, int startIndex)\n{\n   if(startIndex == str.Length -1 )\n      return new string[]{str.Substring(startIndex)};\n\n   List&lt;string&gt; permutations = Permute(str, ++startIndex);\n   List&lt;string&gt; newPermutations = new List&lt;string&gt;();\n\n   foreach(string permutation in permutations)\n   {\n      for(int i=0; i&lt;permutation.Length; i++)\n      {\n         newPermutations.Add(permutation.Insert(i, str[startIndex]));\n      }\n   }\n   return newPermutations;\n}</pre>\n<p>Analysis: Number of recursive calls is equal to N (length of the input string). if L is the level of each recursive call, the run time for each recursive call is L!. So at the top most call, since L = N, it is N!. Total: N! + N-1! + N-2! ... + 1<br>\nApproach 2:<br>\nThe idea here is to put each character in the string in the 1st position and combine it with the permutation of the characters in the rest of the string. As you can see this is also a recursive definition. Pseudo Code:</p>\n<pre>For i=0 to N\n  1. Swap letters 0 and i.\n  2. Permute letters 1 to N-1, printing or saving the entire string each time.</pre>\n<p>Code (C):</p>\n<pre>Permute(char* inputStart, char* current)\n{\n   char *swap;\n   char temp;\n\n   if(*(current + 1) = '')\n      printf(\"%s\\n\", inputStart);\n   else\n   {\n      for(swap = current; *swap != ''; ++swap)\n      {\n         temp = *swap;\n         *swap = *current;\n         *current = temp;\n\n         Permute(inputStart, current + 1);\n\n         //revert the letters\n         *current = *swap;\n         *swap = temp;\n      }\n   }\n}</pre>\n<p>Run time: This solution makes at least N! + N-1! + N-2!+ ... + 1 recursive calls doing 1 unit of work in each call. Compare this to the less number of recursive calls from the approach one, but approach one does increasing more work going back up from each recursive call.</p>\n<div id=\"navmenu\">\n<ul id=\"menu\">\n<li><a href=\"http://www.geeksforgeeks.org/category/c-arrays\" title=\"Questions regarding Arrays\">Arrays</a></li>\n<li><a href=\"http://www.geeksforgeeks.org/category/bit-magic\" title=\"View all posts filed under Bit Magic\">Bit Magic</a></li>\n<li><a href=\"http://www.geeksforgeeks.org/category/c-puzzles\" title=\"View all posts filed under C/C++ Puzzles\">C/C++ Puzzles</a></li>\n<li><a href=\"http://www.geeksforgeeks.org/category/articles\" title=\"View all posts filed under Articles\">Articles</a></li>\n<li><a href=\"http://www.geeksforgeeks.org/category/gfact\" title=\"View all posts filed under GFacts\">GFacts</a></li>\n<li><a href=\"http://www.geeksforgeeks.org/category/linked-list\" title=\"Linked List problems\">Linked Lists</a></li>\n<li><a href=\"http://www.geeksforgeeks.org/category/multiple-choice-question\" title=\"View all posts filed under MCQ\">MCQ</a></li>\n<li><a href=\"http://www.geeksforgeeks.org/category/c-programs\" title=\"Miscellaneous\">Misc</a></li>\n<li><a href=\"http://www.geeksforgeeks.org/category/program-output\" title=\"View all posts filed under Output\">Output</a></li>\n<li><a href=\"http://www.geeksforgeeks.org/category/c-strings\" title=\"Questions related to strings\">Strings</a></li>\n<li><a href=\"http://www.geeksforgeeks.org/category/tree\" title=\"View all posts filed under Trees\">Trees</a></li>\n</ul>\n</div>\n<div id=\"content\">\n<div id=\"post\">\n<div id=\"post-767\">\n<div>\n<div>\n<h2>Write a C program to print all permutations of a given string</h2>\n</div>\n<div>August 2, 2009</div>\n<div></div>\n</div>\n<div id=\"post-content\">\n<p>A permutation, also called an “arrangement number” or “order,” is a rearrangement of the elements of an ordered list S into a one-to-one correspondence with S itself. A string of length n has n! permutation.<br/>\nSource: Mathword(<a href=\"http://mathworld.wolfram.com/Permutation.html\">http://mathworld.wolfram.com/Permutation.html</a>)</p>\n<p>Below are the permutations of string ABC.<br/>\nABC, ACB, BAC, BCA, CAB, CBA</p>\n<p>Here is a solution using backtracking.</p>\n<p><a href=\"http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/NewPermutation.gif\"><img alt=\"NewPermutation\" height=\"231\" src=\"{{ site.baseurl }}/assets/NewPermutation.gif\" width=\"565\"/></a></p>\n<div>\n<div id=\"highlighter_521381\">\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody>\n<tr>\n<td>\n<div>\n<div><code># include &lt;stdio.h&gt;</code></div>\n<div></div>\n<div><code>/* Function to swap values at two pointers */</code></div>\n<div><code>void</code> <code>swap (</code><code>char</code> <code>*x, </code><code>char</code> <code>*y)</code></div>\n<div><code>{</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>char</code> <code>temp;</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>temp = *x;</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>*x = *y;</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>*y = temp;</code></div>\n<div><code>}</code></div>\n<div><code>&nbsp;</code></div>\n<div><code>/* Function to print permutations of string</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;</code><code>This function takes three parameters:</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;</code><code>1. String</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;</code><code>2. Starting index of the string</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;</code><code>3. Ending index of the string. */</code></div>\n<div><code>void</code> <code>permute(</code><code>char</code> <code>*a, </code><code>int</code> <code>i, </code><code>int</code> <code>n) </code></div>\n<div><code>{</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>j; </code></div>\n<div><code>&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(i == n)</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>printf</code><code>(</code><code>\"%s\\n\"</code><code>, a);</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;</code><code>else</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;</code><code>{</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>(j = i; j &lt;= n; j++)</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>swap((a+i), (a+j));</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>permute(a, i+1, n);</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>swap((a+i), (a+j)); </code><code>//backtrack</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;</code><code>}</code></div>\n<div><code>} </code></div>\n<div></div>\n<div><code>/* Driver program to test above functions */</code></div>\n<div><code>int</code> <code>main()</code></div>\n<div><code>{</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;</code><code>char</code> <code>a[] = </code><code>\"ABC\"</code><code>;&nbsp; </code></div>\n<div><code>&nbsp;&nbsp;&nbsp;</code><code>permute(a, 0, 2);</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;</code><code>getchar</code><code>();</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>0;</code></div>\n<div><code>}</code></div>\n</div>\n</td>\n</tr>\n</tbody>\n</table>\n</div>\n</div>\n<p>Output:</p>\n<pre>ABC\nACB\nBAC\nBCA\nCBA\nCAB</pre>\n<p><strong><br/>\nAlgorithm Paradigm: </strong>Backtracking<br/>\n<strong>Time Complexity: </strong>O(n*n!)</p>\n</div>\n</div>\n</div>\n</div>\n<div>\n<p>The algorithm basically works on this logic:</p>\n<p>All permutations of a string X is the same thing as all permutations of each possible character in X, combined with all permutations of the string X without that letter in it.</p>\n<p>That is to say, all permutations of \"abcd\" are</p>\n<ul>\n<li>\"a\" concatenated with all permutations of \"bcd\"</li>\n<li>\"b\" concatenated with all permutations of \"acd\"</li>\n<li>\"c\" concatenated with all permutations of \"bad\"</li>\n<li>\"d\" concatenated with all permutations of \"bca\"</li>\n</ul>\n<p>This algorithm in particular instead of performing recursion on substrings, performs the recursion in place on the input string, using up no additional memory for allocating substrings. The \"backtracking\" undoes the changes to the string, leaving it in its original state.</p>\n</div>\n<p>END</p>","excerpt":"Problem: Write the code for producing/printing permutations of the characters in a string. For example: If \"abc\" is the input string, output permutations should…","frontmatter":{"date":"16 September, 2013","path":"/blog/2013-09-16-string-permutations-using-recursion/","title":"[STRING] Permutations Using Recursion"},"fields":{"readingTime":{"text":"5 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}