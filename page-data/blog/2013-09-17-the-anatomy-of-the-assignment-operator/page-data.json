{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2013-09-17-the-anatomy-of-the-assignment-operator/","result":{"data":{"markdownRemark":{"html":"<p><span style=\"font-size:large;\"><em>by Richard Gillam<br>\nSenior Software Engineer, Text &#x26; International<br>\nTaligent, Inc.</em></span></p>\n<p>My team recently hired someone. Normally, this wouldn't be such a big deal, but we've been looking for someone for a year and a half. In this time, we've interviewed at least a dozen candidates and phone-screened at least a couple dozen more. Practically every candidate we've talked to had at least two years of C++ experience, rated himself a 7 or 8 on a scale of 10 in C++ skill, and had one or two lucrative offers on the table. Unfortunately, we would have rated almost all of them somewhere between a 4 and a 6. In my opinion, this goes to show you that working with C++ for a long time doesn't guarantee you really understand the language.</p>\n<p>Over this time, I've developed a stock interview question that's proven to be a pretty good gauge of C++ knowledge. No one has yet been able to just rip out the correct answer, but we've had several, including the guy we hired, who understood the important issues and were able to get the question right with prompting. As a public service, I'd like to share my stock question and its answer with you and explore the various programming issues it presents.</p>\n<p>The question is as follows:</p>\n<blockquote>\n<p>\nConsider the following class definition:</p>\n<pre>class TFoo : public TSuperFoo {\n    TBar* fBar1;\n    TBar* fBar2;\n    // various method definitions go here...\n}</pre>\n<p>You have a class, <tt>TFoo</tt>, which descends from a class, <tt>TSuperFoo</tt>, and which has two data members, both of which are pointers to objects of class <tt>TBar</tt>. For the purposes of this exercise, consider both pointers to have owning semantics and <tt>TBar</tt> to be a monomorphic class. Write the assignment operator for this class.</p>\n</blockquote>\n<p>This seems like a simple enough exercise, but it gets at some interesting issues. It's a good way to test a programmer's grasp of C++ syntax and C++ style, but more importantly, it tests the programmer's knowledge of C++ memory management and exception handling.</p>\n<p>For the impatient among you, let's cut right to the chase: One correct answer to this question would look something like this:<sup><a href=\"http://www.icu-project.org/docs/papers/cpp_report/the_anatomy_of_the_assignment_operator.html#footnote\">[*]</a></sup></p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    if (this != &amp;that) {\n        TBar* bar1 = 0;\n        TBar* bar2 = 0;\n\n        try {\n            bar1 = new TBar(*that.fBar1);\n            bar2 = new TBar(*that.fBar2);\n        }\n        catch (...) {\n            delete bar1;\n            delete bar2;\n            throw;\n        }\n\n        TSuperFoo::operator=(that);\n        delete fBar1;\n        fBar1 = bar1;\n        delete fBar2;\n        fBar2 = bar2;\n    }\n    return *this;\n}</pre>\n<p>Yes, it's a lot of code. Yes, it's ugly. But all the code you see here is necessary. We'll go through it all piece by piece and see why this is.</p>\n<h3>\"But I never have to write an assignment operator!\"</h3>\n<p>The first reaction I usually get from people is something along the lines of \"But I never have to write assignment operators.\" You should. If you've ever created a new class, you've needed to write an assignment operator.</p>\n<p>Let's examine why this is so. In C++, there are three things every object is expected to be able to do: An object should be able to initialize itself to a default state, it should be able to initialize itself from another instance of the same class, and it should be able to assume the semantic state of another instance of the same class. In C++, these operations are expressed with the default constructor (e.g., <tt>TFoo::TFoo()</tt>), the copy constructor (<tt>TFoo::TFoo(const TFoo&#x26;)</tt>), and the assignment operator (<tt>TFoo::operator=(const TFoo&#x26;)</tt>).</p>\n<p>These three functions are special in C++: If you don't provide them yourself, C++ provides them for you. And automatically makes them public. Among other things, this means you have to define these operations even if you <em>don't want</em> a client to be able to copy or default-construct a particular class. If you don't want a class to be copied, for example, you have to define an empty copy constructor and assignment operator yourself and make them private or protected.</p>\n<p>Furthermore, the compiler isn't guaranteed to create versions of these classes that do exactly what you want them to do. For copying and assignment, for example, the automatically-generated code will do a <em>shallow memberwise copy.</em> If your class has pointer members, this is practically never what you want, and even when you don't have pointer members, this isn't always the right behavior. It's definitely not what we want in our example.</p>\n<p>Even when the default versions of the special functions do what you want them to, it's still generally a good policy to always spell that out explicitly by writing them yourself. It avoids ambiguity, and it forces you to think more about what's going on inside your class. Always give any new class a default constructor, a copy constructor, and an assignment operator.</p>\n<h3>Copy vs. assign</h3>\n<p>Another misconception I see often is a fuzzy idea of the difference between the copy constructor and the assignment operator. They're not the same thing, although they're similar. Let's take a moment to look at the difference.</p>\n<p>The copy constructor and assignment operator do similar things. They both copy state from one object to another, leaving them with equivalent semantic state. In other words, both objects will behave the same way and return the same results when their methods are called. If they have public data members (generally a bad idea), they have the same values. This doesn't necessarily mean that the objects are identical: some purely internal data members (such as caches) might not be copied, or data members pointing to other objects might end up pointing to different objects that are themselves semantically equivalent, rather than pointing to the same objects.</p>\n<p>The difference between the copy constructor and assignment operator is that the copy constructor is a <em>constructor —</em> a function whose job it is to turn raw storage into an object of a specific class. An assignment operator, on the other hand, copies state between two <em>existing objects.</em> In other words, an assignment operator has to take into account the current state of the object when copying the other object's state into it. The copy constructor is creating a new object from raw storage and knows it's writing over garbage. For many classes, the current state of the object doesn't matter and both functions do the same thing. But for some classes (including the one in our example), the current state does matter, and the assignment operator is more complicated.</p>\n<h3>Defining the Function</h3>\n<p><strong>What parameters does the function take?</strong> C++ requires that an assignment operator take one parameter: the thing on the right-hand side of the = sign. This can be of any type, but the assignment operator that C++ automatically generates for you (and therefore, the one we're interested in here) is the one where you have the same type of object on both sides of the = sign. That means the parameter is either an instance of or a reference to an instance of the same class as the object on the left-hand side. You'll pretty much always want to use a reference rather than a full-blown instance of the class (i.e., pass by reference instead of pass by value). This is because passing an object by value requires creating a new instance of the class with the same state as the object passed as a parameter: in other words, its copy constructor must be called. This isn't necessary, and it wastes time. The parameter can be either a const or a non-const reference, but since it would be terrible form for the assignment operator to have side effects on the object on the right-hand side, you should use a const reference.</p>\n<p><strong>What does the function return?</strong> An assignment operator can return anything it wants, but the standard C and C++ assignment operators return a reference to the left-hand operand. This allows you to chain assignments together like so:</p>\n<pre>x = y = z = 3;</pre>\n<p>Unless you have a <em>really good reason,</em> you want to follow this convention. Returning a reference to the right-hand operand or a value (i.e., another whole <tt>TFoo</tt>) would both still allow the simple chain described above to work, but have subtle differences in semantics from the way the standard operators do it that would come out in more complicated expressions involving assignment. Returning a value also forces unnecessary trips through the object's copy constructor, costing you in performance.</p>\n<p>So the outer shell of a properly-written assignment operator would look like this:</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    // copy the state...\n    return *this;\n}</pre>\n<p>(By the way, note that the return statement is \"<tt>return *this\"</tt>, rather than \"<tt>return this</tt>\". That's because <tt>this</tt> is a <em>pointer</em> to <tt>TFoo</tt>. You have to dereference it to get a reference to <tt>TFoo</tt>. Of course, if you forget this, the compiler will remind you.)</p>\n<p><strong>Virtual or non-virtual?</strong> I had one applicant suggest that <tt>operator=</tt> should be a virtual function. Let's take a look at this issue. Many C++ programmers are trained to make everything virtual, and in fact, some older frameworks do just that. In the specific example of the assignment operator, however, it's not a good idea. An override of a virtual function has to take the same parameters as the function it's overriding. Therefore, <tt>TFoo</tt>'s <tt>operator=</tt> function would have to be declared as</p>\n<pre>virtual TSuperFoo&amp; TFoo::operator=(TSuperFoo&amp; that);</pre>\n<p>You could declare the function this way and still have it return <tt>this</tt>, of course, because a reference to a <tt>TFoo</tt> <em>is</em> a reference to a <tt>TSuperFoo</tt>, but we have no way of knowing whether <tt>that</tt> is a reference to a <tt>TFoo</tt> or a reference to some other subclass of <tt>TSuperFoo</tt>. If it's not a <tt>TFoo</tt>, you have several problems. You'd have to check <tt>that</tt>'s class, which can be expensive. If it isn't a <tt>TFoo</tt>, you obviously wouldn't want to try to carry out the assignment, but then you'd have to define some kind of error-handling protocol to handle this situation. Better just to make <tt>operator=</tt> take the right type and let the compiler check the classes of your operands for you at compile time.</p>\n<p>Of course, as soon as each class has operands with different types, the functions have different signatures and the <tt>operator=</tt> function is no longer being overridden. So it doesn't make sense to make <tt>operator=</tt> virtual.</p>\n<h3>Owning and Aliasing Pointers</h3>\n<p>Okay, now that we've got the preliminaries out of the way, we can get into the actual nitty-gritty of having our assignment operator actually perform an assignment. Let's refresh our memory of what the object we're working on looks like:</p>\n<pre>class TFoo : public TSuperFoo {\n    TBar* fBar1;\n    TBar* fBar2;\n    // method definitions...\n};</pre>\n<p>It seems the obvious way to do the assignment would be this:</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    fBar1 = that.fBar1;\n    fBar2 = that.fBar2;\n    return *this;\n}</pre>\n<p>Unfortunately, that's the wrong answer here. Remember that in the original question I said that <tt>fBar1</tt> and <tt>fBar2</tt> are <em>owning</em> pointers. To understand why the above example won't do what we want, we need to take a look at the unique problems of C++ memory management.</p>\n<p>Because of its evolution from C, C++ is much closer to the hardware than most other object-oriented languages. One of the chief consequences of this is that you have to do your own memory management. Every <tt>new</tt> that happens during a program's execution must be balanced by one and only one <tt>delete</tt>. You don't want objects you've allocated to clutter up memory after you're done with them, you don't want to try to delete an object more than once and you don't want to access an object after you've deleted it. Double-deleting an object can corrupt the memory manager's free list, leading to crashes down the road; reading through a pointer to a deleted object (a \"dangling pointer\") can lead to wrong results; and writing through a dangling pointer can corrupt other objects or cause crashes. Failing to delete an object you're done with (a \"memory leak\") is less obviously malignant, but can seriously degrade performance and eventually cause crashes when the system runs out of memory.</p>\n<p>In a system of any complexity, sticking to this \"one delete for every new\" rule can be quite difficult, so a strict protocol for managing memory is necessary. The basic rule we follow at Taligent is that for every object in the runtime environment, there is one and only one pointer to it through which the object can be deleted. This pointer is an \"owning pointer,\" and the object or function containing that pointer is the object's \"owner.\" All other pointers to the object are called \"aliasing pointers.\" The owner of the object expects to delete the object; objects with aliasing pointers don't.</p>\n<p>So when we say that <tt>TFoo</tt>'s two <tt>TBar</tt> pointers are owning pointers, we're saying that <tt>TFoo</tt> expects to delete those <tt>TBar</tt>s. In other words, its destructor looks like this:</p>\n<pre>TFoo::~TFoo()\n{\n    delete fBar1;\n    delete fBar2;\n}</pre>\n<p>You can see that if more than one <tt>TFoo</tt> object points to a given <tt>TBar</tt>, then as soon as one of those <tt>TFoo</tt>s is deleted (taking the <tt>TBar</tt>s down with it), the other <tt>TFoo</tt>s are hosed. The next time any one of them tried to access one of its <tt>TBar</tt> objects, it'd be reading or writing through a dangling pointer, with potentially disastrous consequences. Therefore, every <tt>TFoo</tt> must have its own unique <tt>TBar</tt> objects, which means our assignment operator must create new copies of the source object's <tt>TBar</tt>s for the destination object to point to.</p>\n<p>In some cases, of course, it's overkill to make a copy of an object, because the current owner of the object is just going to delete that object after passing its content on to another object. In other words, one object is <em>transferring ownership</em> of an object to another object. This happens quite frequently, in fact. A simple factory method starts out with ownership of the object it creates, but when it returns its value, it passes ownership of that object to the caller. Its return value is an owning pointer. At other times, a function returns a pointer to an object but intends that the caller merely use it for a short time to perform some operation. Ownership is not transferred; the return value is an aliasing pointer.</p>\n<p>When you have functions that return pointers or have pointer parameters, you must make it explicit whether the function transfers ownership, and you must then make sure that code calling the function upholds these semantics. C++ doesn't do any of this for you. Sometimes you can do this through the parameter types (references are virtually always aliases, and const pointers are always aliases), and sometimes you have to do it with naming conventions (at Taligent, for example, we use \"adopt,\" \"orphan,\" and \"create\" in the names of functions that transfer ownership).</p>\n<p>In the case of the assignment operator, our parameter is a const reference to another <tt>TFoo</tt>. That alone signifies that we are not taking ownership of its internal state (there are some very rare, but important, exceptions to this rule—we'll look at one later). Since <tt>TFoo</tt>'s pointers are defined as owning pointers, however, we have to reconcile the difference in semantics by making new copies of the objects the other <tt>TFoo</tt> points to.</p>\n<p>As an aside, it's worth mentioning that there are occasions where copying objects to maintain ownership semantics is too expensive. In these situations, a technique called <em>reference counting</em> can be used. We'll touch briefly on reference counting later.</p>\n<h3>memcpy() is evil!</h3>\n<p>So we have to copy the <tt>TBar</tt>s in our assignment operator. I've seen a lot of interesting attempts to do this. The most frightening was</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    memcpy(&amp;fBar1, &amp;that.fBar1, sizeof(fBar1));\n    memcpy(&amp;fBar2, &amp;that.fBar2, sizeof(fBar2));\n\n    return *this;\n}</pre>\n<p>I really hope this guy was just nervous. This code just copies the <em>pointer values</em> from one <tt>TFoo</tt> to the other. In other words, it's an ugly way of doing</p>\n<pre>fBar1 = that.fBar1;\nfBar2 = that.fBar2;</pre>\n<p>Closer to the mark, but ever scarier in terms of its results, is</p>\n<pre>memcpy(fBar1, that.fBar1, sizeof(TBar));\nmemcpy(fBar2, that.fBar2, sizeof(TBar));</pre>\n<p>This would copy the data members of <tt>that</tt>'s <tt>TBar</tt>s into <tt>this</tt>'s <tt>TBar</tt>s, so <tt>this</tt> and <tt>that</tt> retain their own separate <tt>TBar</tt> objects. So we're doing well so far. The problem is that it bypasses the assignment operator and copy constructor for <tt>TBar</tt>, so if <tt>TBar</tt> has any owning pointers of its own, you have the same problem. You'll also have problems if <tt>TBar</tt> owns locks or system resources that need to be properly cleaned up or duplicated when you change the internal state of the object. And, of course, if any of these pointers is <tt>NULL</tt>, you'll probably crash.</p>\n<p>Finally, I had one applicant propose</p>\n<pre>fBar1 = new TBar;\nmemcpy(fBar1, that.fBar1, sizeof(TBar));\nfBar2 = new TBar;\nmemcpy(fBar2, that.fBar2, sizeof(TBar));</pre>\n<p>This is kind of a cheap way of initializing brand-new <tt>TBar</tt>s from existing ones, or copy constructing them without using the copy constructor. It suffers from all of the same limitations as the previous example, plus an additional one we'll get to in a moment.</p>\n<p>Keep in mind one thing: <em><tt>memcpy()</tt> is evil!</em> It's a C construct you should never use in C++. <tt>memcpy()</tt> operates on bits and bytes, not on objects. At best, it just looks ugly and forces you to be concerned with things you shouldn't need to worry about, like the size of <tt>TBar</tt>. At worst, it fails to take into account what's actually being stored in the objects you're copying, leading to erroneous results, or even uglier code that takes the special cases into account. Never use <tt>memcpy()</tt> in C++ code. There are always better, more object-oriented ways to do the same thing.</p>\n<p>So what's the right answer? Since the <tt>TFoo</tt> expects to delete the <tt>TBar</tt>s it points to, we have to create new ones for it to point to. And we can create duplicates of the other <tt>TFoo</tt>'s <tt>TBar</tt>s by using <tt>TBar</tt>'s copy constructor (remember from our introduction that every object has a copy constructor), so the correct solution (so far) would look like this:</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    fBar1 = new TBar(*that.fBar1);\n    fBar2 = new TBar(*that.fBar2);\n\n    return *this;\n}</pre>\n<h3>Plugging the leaks</h3>\n<p>Of course, there's still a glaring error here: Remember that <tt>fBar1</tt> and <tt>fBar2</tt> are owning pointers. This means that <tt>TFoo</tt> is responsible for deleting them. Here, we've copied right over the top of these pointers without taking into account their former values. This'd be okay if we were writing a copy constructor, where we're guaranteed that <tt>fBar1</tt> and <tt>fBar2</tt> contain garbage, but it's not okay for an assignment operator. In the assignment operator, <tt>fBar1</tt> and <tt>fBar2</tt> are both valid pointers to <tt>TBar</tt> objects. If you just write over them, you now have two <tt>TBar</tt> objects in memory that <em>nobody</em> points to anymore (or at least, no one who points to them expects to have to delete them). This is a memory leak. Memory leaks won't cause your program to crash or produce wrong results, at least not right away. Instead, depending on how numerous and bad they are, they'll slowly degrade your program's performance. And if you run the program long enough, you'll run out of memory and it <em>will</em> crash.</p>\n<p>So we have to delete the objects that we currently own before we can create new ones:</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    delete fBar1;\n    fBar1 = new TBar(*that.fBar1);\n    delete fBar2;\n    fBar2 = new TBar(*that.fBar2);\n\n    return *this;\n}</pre>\n<h3>Assigning yourself</h3>\n<p>Now we're beginning to get to something reasonable. But we're not quite there yet. Consider the following expression:</p>\n<pre>foo1 = foo1;</pre>\n<p>This might seem like kind of a silly example, but it does happen. Consider a setter function on some object where the variable being set is a <tt>TFoo</tt> and the other value is passed in. A caller knows he wants to set that variable to \"x.\" The caller shouldn't have to check to see whether the value of that variable is already \"x.\" If the value already <em>is</em> \"x\" and the caller doesn't check for this, look at what happens in our code: <tt>this</tt> and <tt>that</tt> refer to the same object, so by the time we get down to \"<tt>fBar1 = new TBar(*that.fBar1)</tt>\", <tt>that.fBar1</tt> is gone. \"<tt>delete fBar1</tt>\" also deleted <tt>that.fBar1</tt>. The call to <tt>TBar</tt>'s copy constructor will either crash because it's trying to access a deleted object, or it'll get away with that, create a brand-new <tt>TBar</tt>, and initialize it with the potentially random contents of raw memory. Worse, most of the time the data that had been in those two objects won't have been overwritten yet, so it'll probably work right 90% of the time and randomly fail the other 10%. This kind of bug is notoriously hard to track down.</p>\n<p>There are many ways of coding around this, but the obvious answer is the best: just check at the top of the function to see whether you're assigning to yourself, and drop out if you are.</p>\n<p>Of course, you can't just write</p>\n<pre>if (this == that)</pre>\n<p>because <tt>this</tt> and <tt>that</tt> are different types (<tt>this</tt> is a pointer and <tt>that</tt> is a reference). There are two ways of rectifying this: you can turn <tt>this</tt> into a reference, or turn <tt>that</tt> into a pointer. In other words, you could write</p>\n<pre>if (*this == that)</pre>\n<p>or you could write</p>\n<pre>if (this == &amp;that)</pre>\n<p>Keep in mind that these two expressions don't do the same thing. The first example tests semantic equality, and the second example tests identity. In other words, \"<tt>if (*this == that)</tt>\" calls <tt>TFoo</tt>'s equality operator. If that object doesn't have one (it's <em>not</em> required or created for you), you're automatically hosed. If it does, it'll go through all the externally-visible data members of the two objects one by one looking for a difference, which is bound to be much slower than \"<tt>if (this != &#x26;that)</tt>\", which is a simple pointer comparison. \"<tt>if (this == &#x26;that)</tt>\" will return true only if <tt>this</tt> and <tt>that</tt> refer to the <em>same object,</em> not merely to two objects that \"look the same.\" You'll occasionally do some unnecessary work this way, but it saves a lot of time and it protects you from crashing, which is really the point.</p>\n<p>So (switching to \"<tt>!=</tt>\" for simplicity) our operator now looks like</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    if (this != &amp;that) {\n        delete fBar1;\n        fBar1 = new TBar(*that.fBar1);\n        delete fBar2;\n        fBar2 = new TBar(*that.fBar2);\n    }\n    return *this;\n}</pre>\n<h3>Honoring your ancestry</h3>\n<p>We've also forgotten one other important detail. Remember the first line of our sample class definition:</p>\n<pre>class TFoo : public TSuperFoo {</pre>\n<p><tt>TFoo</tt> is not a root class; it has a base class. This means we have to copy over the base class's data members too. If we were writing a copy constructor, we wouldn't generally have to worry about this, because the compiler will make sure our base class members are initialized before our constructor is called. But the compiler doesn't do anything like this for us with assignment operators; we have to do it ourselves.</p>\n<p>The easiest way to do this is to call our superclass's assignment operator ourselves. You could do this by casting yourself to your base class:</p>\n<pre>*((TSuperFoo*)this) = that;</pre>\n<p>but it's much more readable to just call the inherited function by name:</p>\n<pre>TSuperFoo::operator=(that);</pre>\n<p>By the way, I've had a couple of people try</p>\n<pre>inherited::operator=(that);</pre>\n<p>Some of the older compilers on the Mac provided the <tt>inherited</tt> keyword, which I always liked. Unfortunately, it's not included in the C++ standard because it doesn't work well with multiple inheritance: in portable C++, you actually have to refer to your immediate superclass by name. So now we have</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    if (this != &amp;that) {\n        TSuperFoo::operator=(that);\n\n        delete fBar1;\n        fBar1 = new TBar(*that.fBar1);\n        delete fBar2;\n        fBar2 = new TBar(*that.fBar2);\n    }\n    return *this;\n}</pre>\n<h3>Cleaning up after yourself</h3>\n<p>We're still not really out of the woods here. The code above will work great... unless we encounter an error while trying to create one of our <tt>TBar</tt> objects. If we get an exception while creating a <tt>TBar</tt> object, the data member we're setting retains its old value, which now points to a deleted object. If we continue to use this <tt>TFoo</tt>, we'll probably eventually crash because of the dangling pointer. If we delete the <tt>TFoo</tt> in response to the exception, we'll probably blow sky high trying to double-delete the <tt>TBar</tt>.</p>\n<p>If we know that the calling function will delete the object if assigning to it fails, we can just zero out the pointers after deleting the objects they refer to:</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    if (this != &amp;that) {\n        TSuperFoo::operator=(that);\n\n        delete fBar1;\n        fBar1 = 0;\n        fBar1 = new TBar(*that.fBar1);\n\n        delete fBar2;\n        fBar2 = 0;\n        fBar2 = new TBar(*that.fBar2);\n    }\n    return *this;\n}</pre>\n<p>Unfortunately, this only works if you're certain the calling function will catch the exception and delete the <tt>TFoo</tt>, or if <tt>NULL</tt> is a valid value for the <tt>TBar</tt> pointers. (Actually, if <tt>NULL</tt> is a valid value, you'll also have to check the incoming object's <tt>fBar1</tt> and <tt>fBar2</tt> for <tt>NULL</tt> before trying to new up new <tt>TBar</tt>s from them.)</p>\n<p>A better way to handle the problem is to make sure that the creation of a new object succeeds before you do anything to the variable you're assigning to. This way, if creation fails, you're still pointing to a perfectly good <tt>TBar</tt>— the assignment operation simply didn't have an effect. In fact, since we have two <tt>TBar</tt>s, we should new up <em>both</em> of them before carrying out the assignment. This will ensure that the <tt>TFoo</tt> is always in an internally consistent state; either the whole assignment happened or none of it did:</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    if (this != &amp;that) {\n        TSuperFoo::operator=(that);\n\n        TBar* bar1;\n        TBar* bar2;\n\n        bar1 = new TBar(*that.fBar1);\n        bar2 = new TBar(*that.fBar2);\n\n        delete fBar1;\n        fBar1 = bar1;\n        delete fBar2;\n        fBar2 = bar2;\n    }\n    return *this;\n}</pre>\n<p>But there's a problem with this solution: Consider what happens if creation of <tt>bar1</tt> succeeds and creation of <tt>bar2</tt> fails. You'll exit with the actual object untouched, but what happens to the <tt>TBar</tt> pointed to by <tt>bar1</tt>? That's right; it leaks. In order to avoid this, you actually have to catch and re-throw the exception and delete <tt>bar1</tt> if it's been created. In order to tell if you're created <tt>bar1</tt>, you need to set it to <tt>NULL</tt> first, too. <em>And,</em> so we're really sure the assignment doesn't do anything until we know we've been able to create both of the new <tt>TBar</tt>s, we can't call our inherited <tt>operator=</tt> function until after the try/catch block. So this all gets rather complicated:</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    if (this != &amp;that) {\n        TBar* bar1 = 0;\n        TBar* bar2 = 0;\n\n        try {\n            bar1 = new TBar(*that.fBar1);\n            bar2 = new TBar(*that.fBar2);\n        }\n        catch (...) {\n            delete bar1;\n            delete bar2;\n            throw;\n        }\n\n        TSuperFoo::operator=(that);\n        delete fBar1;\n        fBar1 = bar1;\n        delete fBar2;\n        fBar2 = bar2;\n    }\n    return *this;\n}</pre>\n<h3>Delegating our work</h3>\n<p>Of course, we're not really handling the exception here; we're just catching the exception to enable us to clean up properly. The try/catch block is a really ugly construct to have to use in this way. It'd be really nice if we could lose it.</p>\n<p>One of the niceties of C++ exception handling is that destructors for any stack-based objects are guaranteed to be called even if the function that declares them exits prematurely with an exception or a return statement. We can take advantage of this behavior by having an object whose destructor deletes the object that would otherwise leak.</p>\n<p>The new ANSI C++ standard provides us with just such an object: It's called <tt>auto_ptr</tt>. Using <tt>auto_ptr</tt>, we can write</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    if (this != &amp;that) {\n        auto_ptr&lt;TBar&gt; bar1 = new TBar(*that.fBar1);\n        auto_ptr&lt;TBar&gt; bar2 = new TBar(*that.fBar2);\n\n        TSuperFoo::operator=(that);\n        delete fBar1;\n        fBar1 = bar1.release();\n        delete fBar2;\n        fBar2 = bar2.release();\n    }\n    return *this;\n}</pre>\n<p>The <tt>release()</tt> function gets rid of the <tt>auto_ptr</tt>'s reference to the object so that it won't delete the object in its destructor. So the <tt>auto_ptr</tt> will only delete the object it points to if we exit the function with an exception before getting to the <tt>release()</tt> call. Which is correct; the only things in this function which can fail are the constructor calls.</p>\n<h3>Taking full advantage</h3>\n<p>You've probably already guessed this part: We can actually utilize <tt>auto_ptr</tt> more fully than this. <tt>auto_ptr</tt> actually implements owning pointer semantics for us; if you assign to an <tt>auto_ptr</tt>, it deletes the object it points to before taking on the new pointer, and if an <tt>auto_ptr</tt> goes out of scope, it also automatically deletes the object it points to. So if we relaxed the rules of our exercise to allow us to redefine the class, we could redefine the class using <tt>auto_ptr</tt>:</p>\n<pre>class TFoo : public TSuperFoo {\n    auto_ptr&lt;TBar&gt; fBar1;\n    auto_ptr&lt;TBar&gt; fBar2;\n    // method definitions...\n};</pre>\n<p>Functions accessing the objects pointed to by <tt>fBar1</tt> and <tt>fBar2</tt> would look exactly the same as they did when <tt>fBar1</tt> and <tt>fBar2</tt> were regular pointers; <tt>auto_ptr</tt> defines its <tt>*</tt> and <tt>-></tt> operators to do the same thing as those for a regular pointer.</p>\n<p>And now we can take full advantage of <tt>auto_ptr</tt> in our assignment operator:</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    if (this != &amp;that) {\n        TSuperFoo::operator=(that);\n\n        fBar1 = new TBar(*that.fBar1);\n        fBar2 = new TBar(*that.fBar2);\n    }\n    return *this;\n}</pre>\n<p><tt>auto_ptr</tt> also takes care of deleting the objects previously pointed to by <tt>fBar1</tt> and <tt>fBar2</tt>. One thing it doesn't automatically do for us, however, is create a new object to point to; we have to do that ourselves. If we just did</p>\n<pre>fBar1 = that.fBar1;\nfBar2 = that.fBar2;</pre>\n<p>instead, we'd actually inadvertently affect <tt>that</tt>, when that's not what we want to do (in fact, by declaring <tt>that</tt> as const, we've <em>promised</em> not to affect it). This is because an <tt>auto_ptr</tt>'s assignment operator passes ownership from one object to the other (this is the once exception to the rule about passing ownership that I mentioned earlier); in other words, it'd leave <tt>that.fBar1</tt> and <tt>that.fBar2</tt> with null pointers.</p>\n<p>Actually, our <tt>auto_ptr</tt> solution doesn't do exactly the same thing as the previous example. If we want to make sure that all of the assignment happens or none of it, we still need the temporary variables. But this is a situation where the ownership-passing property of <tt>auto_ptr</tt>'s assignment operator helps us:</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    if (this != &amp;that) {\n        auto_ptr&lt;TBar&gt; bar1 = new TBar(*that.fBar1);\n        auto_ptr&lt;TBar&gt; bar2 = new TBar(*that.fBar2);\n\n        TSuperFoo::operator=(that);\n        fBar1 = bar1;\n        fBar2 = bar2;\n    }\n    return *this;\n}</pre>\n<p>Here, if the second <tt>new</tt> operation fails, the first new <tt>TBar</tt> will be deleted by <tt>auto_ptr</tt>'s destructor when we exit the function. But if both <tt>new</tt>s succeed, the assignments will delete the objects <tt>fBar1</tt> and <tt>fBar2</tt> previously pointed to, and will also zero out <tt>bar1</tt> and <tt>bar2</tt> so that their destructors don't delete anything when we exit the function.</p>\n<p>The other beauty of <tt>auto_ptr</tt> is its documentary value; if a pointer is declared as an <tt>auto_ptr</tt>, you know it's an owning pointer. If you consistently use <tt>auto_ptr</tt>s for all owning pointers and regular pointers only for aliasing pointers, the meanings of pointers are no longer ambiguous and you don't have to worry as much about naming conventions and documentation.</p>\n<p>Of course, <tt>auto_ptr</tt> isn't available on all C++ compilers yet; if you're concerned about portability, don't use it. Do the assignment the first way I described, or make your own <tt>auto_ptr</tt>-like class. But if your compiler provides <tt>auto_ptr</tt>, and you're not worried about portability, it's definitely the way to go.</p>\n<h3>Miscellanea</h3>\n<p>I've gotten a couple questions in interviews that I probably should address briefly here. First, I had at least one applicant ask me why I could do things like</p>\n<pre>fBar1 = new TBar(*that.fBar1);</pre>\n<p>when <tt>fBar1</tt> is a private member. The answer is that access control in C++ is done on an <em>class by class</em> basis, not on an instance-by-instance basis. Any instance of a class can access the private members of any other instance of the same class, so code like that shown in the example above is legal.</p>\n<p>I also sometimes have people write code like</p>\n<pre>if (fBar1 != 0)\n    delete fBar1;</pre>\n<p>This is actually unnecessary. The <tt>delete</tt> operator in C++ automatically performs this null check for you, so it's okay to delete a null pointer.</p>\n<h3>The <em>real</em> answer</h3>\n<p>Actually, I lied at the beginning of this article. There is an infinitely better solution to the problem as I stated it than the one we just worked our way to.</p>\n<p>To see what I'm getting at, consider two points:</p>\n<ul>\n<li>If any other objects contain aliasing pointers to <tt>TFoo</tt>'s <tt>TBar</tt> objects, they will be invalid after you assign to the <tt>TFoo</tt>.</li>\n<li>Every object in a well-designed C++ system has a default constructor, a copy constructor, and an assignment operator.</li>\n</ul>\n<p>That's right; you can perform the whole assignment just by calling <em><tt>TBar</tt>'s</em> assignment operator. That solution looks like this:</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    TSuperFoo::operator=(that);\n    *fBar1 = *(that.fBar1);\n    *fBar2 = *(that.fBar2);\n\n    return *this;\n}</pre>\n<p>This is <em>so</em> much easier. So why didn't I start with this at the outset? There are several reasons:</p>\n<ul>\n<li>Going with the longer solution was a good way to explore many of the details of C++ memory management and syntax.</li>\n<li>The shorter solution won't work if <tt>NULL</tt> is a valid value for <tt>fBar1</tt> and <tt>fBar2</tt>. In this case, you'd have to use a hybrid solution: follow the longer example when you're copying an object into a null pointer, and the shorter example when you're copying an object into an object. (I'll leave this example as an exercise for the reader.)</li>\n<li>The shorter solution won't work if we want to transactionize the whole assignment. In other words, if we have a situation where <em>both</em> assignments have to complete successfully in order for our object to be in a consistent state, we can't use the simple solution because there's no way to roll back our changes to <tt>fBar1</tt> if assigning to <tt>fBar2</tt> throws an exception. You'd have to use the longer example. However, if the two data members are unrelated, or you know their assignment operators can't throw an exception, this solution is perfectly adequate.</li>\n<li>The shorter solution won't work if <tt>TBar</tt> is a polymorphic class. Let's take a closer look at this situation.</li>\n</ul>\n<h3>Handling polymorphism</h3>\n<p>I stated in the original problem that you could assume for the purposes of the exercise that <tt>TBar</tt> was a monomorphic class— that is, that <tt>TBar</tt> has no subclasses. If <tt>TBar</tt> is a polymorphic class—that is, if we know it has or can have subclasses—then the shorter solution won't work.</p>\n<p>Let's pretend for a moment that <tt>TBar</tt> is an abstract class and that it has two concrete subclasses, <tt>TDerivedBar1</tt> and <tt>TDerivedBar2</tt> (yeah, I know I'm really creative with these names). All we have in our short example are pointers to <tt>TBar</tt>. Each assignment above will call <em><tt>TBar</tt>'s</em> <tt>operator=</tt> function, <em>not</em> the <tt>operator=</tt> function of <tt>TDerivedBar1</tt> or <tt>TDerivedBar2</tt> (remember, <tt>operator=()</tt> isn't virtual). This means that any data members defined by the <tt>TDerivedBar</tt> classes won't be copied. This is called <em>slicing,</em> and it's something you have to watch out for in C++. You must always pay special attention to whether a class is polymorphic or monomorphic. Polymorphism imposes special restrictions on what you can do with your objects, and the compiler doesn't enforce these restrictions.</p>\n<p>Of course, we could theoretically get around these problems by making <tt>TBar</tt>'s <tt>operator=</tt> function virtual. If <tt>this->fBar1</tt> is an instance of <tt>TDerivedBar1</tt>, you'll call <tt>TDerivedBar1::operator=()</tt> instead of <tt>TBar::operator=()</tt>. But if it's a <tt>TDerivedBar2</tt>, you're in trouble. <tt>TDerivedBar1</tt> isn't going to know what to do with <tt>TDerivedBar2</tt>'s members; it has nowhere to put them. You really want it to look like the object pointed to by <tt>this->fBar1</tt> has morphed from a <tt>TDerivedBar2</tt> to a <tt>TDerivedBar1</tt>. There's only one way to do this, and that's to delete the <tt>TDerivedBar2</tt> and new up a brand-new <tt>TDerivedBar1</tt>.</p>\n<p>So our longer solution, where we delete the old objects and replace them with newly-created objects (either directly or with <tt>auto_ptr</tt>), is closer to the mark. But it won't work as written, either. Consider the line</p>\n<pre>fBar1 = new TBar(*that.fBar1);</pre>\n<p>If <tt>TBar</tt> is an abstract class, this will generate a compile-time error, because you're trying to create an instance of a class that can't be instantiated. If <tt>TBar</tt> is a concrete, but polymorphic, class, it'll compile, but you'll get slicing again: the <tt>new</tt> expression will only return an instance of <tt>TBar</tt>, even if the original object was a <tt>TDerivedBar1</tt>. At best this isn't a real copy and at worst it has incomplete and inconsistent state.</p>\n<p>The C++ language doesn't provide a built-in way around this problem, unfortunately— if you need to copy an object polymorphically, you have to do it yourself. The typical way to do this is to define a virtual function called <tt>clone()</tt> and have every class that inherits <tt>clone()</tt> override it to call its own copy constructor.</p>\n<pre>class TBar {\n    ...\n    virtual TBar* clone() const = 0;\n    ...\n};\n\nTDerivedBar1::clone() const\n{\n    return new TDerivedBar1(*this);\n}\n\nTDerivedBar2::clone() const\n{\n    return new TDerivedBar2(*this);\n}</pre>\n<p>Once you've given all the classes in question a <tt>clone()</tt> method, you can go back and rewrite <tt>TFoo</tt>'s assignment operator properly:</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    if (this != &amp;that) {\n        auto_ptr&lt;TBar&gt; bar1 = that.fBar1-&gt;clone();\n        auto_ptr&lt;TBar&gt; bar2 = that.fBar2-&gt;clone();\n\n        TSuperFoo::operator=(that);\n        fBar1 = bar1;\n        fBar2 = bar2;\n    }\n    return *this;\n}</pre>\n<h3>Counted pointers and other esoterica</h3>\n<p>There are a few other points about owning and aliasing pointers that I wanted to make.</p>\n<p>The first is that aliasing pointers can be fragile. If you have other objects that have aliasing pointers to a <tt>TFoo</tt>'s <tt>fBar1</tt> object, they'll be bad after a call to <tt>TFoo</tt>'s assignment operator. This means you have to be careful that any aliases have a shorter lifetime than the object's owning pointer. Typically, aliases are short-lifetime objects: You obtain a aliasing pointer to a <tt>TFoo</tt>'s <tt>fBar1</tt> at the top of a function, use it to perform some operations on the <tt>TBar</tt>, and then let it go out of scope at the end of the function. If you were instead trying to keep the alias around for an indefinite period of time by making it a data member of some other object (you'd probably do this for performance or convenience), you're asking for trouble. The solution to this problem is almost always to make the persistent pointer point to something with a longer and more well-defined lifespan (for example, the <tt>TFoo</tt> that owns the <tt>TBar</tt> you're interested in).</p>\n<p>Of course, there are situations where the relative lifetimes of a network of objects aren't clear, and therefore it isn't clear who should own whom, or which pointers can be kept around persistently. The solution to this problem is the same as the solution to the problem of spending too much time copying objects to maintain clear ownership semantics: reference counting.</p>\n<p>In reference counting, each object keeps track of how many other objects point to it. These objects refer to the counted object through a <em>counted pointer, _which functions more or less like an aliasing pointer except that it notifies the object when it no longer refers to it (either because it now points to something else, or because it's going away). _Nobody</em> deletes the counted object; the counted object deletes <em>itself</em> when no one is left pointing to it.</p>\n<p>The C++ standard doesn't provide canned <tt>auto_ptr</tt>-style objects that do reference counting, but most frameworks do. It can be expensive, especially in virtual-memory environments, though, so think twice before resorting to this solution.</p>\n<p>An additional caveat is that if you use reference counting to improve performance in a situation where you'd otherwise be copying objects at the drop of a hat, you don't want to change the semantics of what you're doing. When you're sharing to avoid unnecessary copying, every object still expects to behave like he has his own copy of the shared object. That means the object can only be shared until someone tries to <em>change</em> it. At that point, the object trying to change it must create a copy of his own. This behavior is called <em>copy-on-write semantics.</em> Often, it's convenient to create a special counted-pointer class that enforces copy-on-write semantics transparently. This is almost never provided by a framework, however; you'd have to code it yourself.</p>\n<p>Note, by the way, that in a garbage-collected environment like Java, much of this material is still relevant. It's true that the garbage collector frees you from having to worry about deleting things (much as reference counting does, but usually with less overhead), but that's it. It doesn't free you from having to make sure your object remains in a consistent state if the assignment fails halfway through. It doesn't free you from worrying about ownership semantics with resources other than memory blocks (such as disk files, window-system elements, or locks). And it doesn't free you from having to worry about when you need to duplicate an object and when an object can be shared. In fact, it exacerbates the last two problems. In C++, for example, an object can release its system resources in its destructor, so that all you have to worry about is deleting the object itself (and not even that if it's in a local variable), whereas you have to explicitly release them in Java. In C++, you can usually use \"const\" in interfaces to tell whether an object can change another object's state or not, where Java lacks \"const,\" forcing the use of ad-hoc conventions similar to the ones we use in C++ for ownership semantics (or forcing a lot of extra copying). And in both languages, you have to worry about which objects referring to a shared object should see the change if the shared object changes (i.e., when do you give an object its own copy of another object, and when can you legitimately share?)</p>\n<p>Garbage collection is definitely not a panacea.</p>\n<h3>Conclusion</h3>\n<p>Well, there you have it: a whirlwind tour of some of the finer points of C++ memory management, as seen through the lens of a simple assignment operator. C++ is a monster of a language, and writing good code in it takes some practice and some concentration. I hope these pointers help illuminate some of the more esoteric but important areas of C++ programming for you and help you to write better code.</p>\n<p>And who knows? My team still has an opening.</p>\n<h3>Bibliography</h3>\n<p>Goldsmith, David, <em>Taligent's Guide to Designing Programs.</em> Reading, MA: Addison-Wesley, 1994. Affectionately known as \"Miss Manners\" around Taligent, this book is the definitive reference for low-level C++ details like the ones we've been discussing. Most of this material comes straight from this book. Every C++ programmer should read it.</p>\n<p>Meyers, Scott, <em>Effective C++.</em> Reading, MA: Addison-Wesley, 1992. Similar to \"Miss Manners,\" but a little more basic.</p>\n<p>Coplien, James O., <em>Advanced C++ Programming Styles and Idioms.</em> Reading, MA: Addison-Wesley, 1992.</p>\n<p>Alger, Jeff, <em>Secrets of the C++ Masters.</em> Cambridge, MA: Ap Professional, 1995. Excellent coverage of smart pointers.</p>\n<p><span style=\"color:#000080;\">__<big><big><big>The Assignment Operator Revisited</big></big></big> _<em></span></em><br>\nby Richard Gillam<br>\nAdvisory Software Engineer, Text &#x26; International<br>\nIBM Center for Java Technology–Silicon Valley_</p>\n<p>If you think you know it all in the C++ world, it must mean you’re not talking to your colleagues very much. If I had any pretensions to knowing it all when I wrote my assignment-operator article (\"<a href=\"http://www.icu-project.org/docs/papers/cpp_report/the_anatomy_of_the_assignment_operator.html\">The Anatomy of the Assignment Operator</a>,\" <em>C++ Report,</em> Nov/Dec 1997), they didn’t last long afterwards.</p>\n<p>The assignment-operator article drew a huge response, with a lot of people sending me corrections and disagreements of various kinds. The issues have been mounting up, so I thought maybe a follow-on article to discuss the issues would be appropriate.</p>\n<h3>The big mistake</h3>\n<p>One I heard about almost instantly from several people (and which I’m really glad I heard about before delivering a talk on this subject at C++ World) was a rather serious mistake. When I first did this article, I had the big \"right answer\" like this:</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    if (this != &amp;that) {\n        TSuperFoo::operator=(that);\n        TBar* bar1 = 0;\n        TBar* bar2 = 0;\n\n        try {\n            bar1 = new TBar(*that.fBar1);\n            bar2 = new TBar(*that.fBar2);\n        }\n        catch (...) {\n            delete bar1;\n            delete bar2;\n            throw;\n        }\n\n        delete fBar1;\n        fBar1 = bar1;\n        delete fBar2;\n        fBar2 = bar2;\n    }\n    return *this;\n}</pre>\n<p>This was wrong, and it was caught in the review process. The problem here is that if you’re trying to transactionize the assignment, so that either all of it happens or none of it happens, this breaks that. If an exception occurs trying to new up <tt>bar1</tt> or <tt>bar2</tt>, the <tt>TFoo</tt> part of the object won’t have changed, but the <tt>TSuperFoo</tt> part will have. The call to <tt>TSuperFoo::operator=()</tt> can’t go at the top of the function.</p>\n<p>As I said, this was caught during the review process. So when the article ran, this example looked like this:</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    if (this != &amp;that) {\n        TBar* bar1 = 0;\n        TBar* bar2 = 0;\n\n        try {\n            bar1 = new TBar(*that.fBar1);\n            bar2 = new TBar(*that.fBar2);\n        }\n        catch (...) {\n            delete bar1;\n            delete bar2;\n            throw;\n        }\n\n        TSuperFoo::operator=(that);\n        delete fBar1;\n        fBar1 = bar1;\n        delete fBar2;\n        fBar2 = bar2;\n    }\n    return *this;\n}</pre>\n<p>Unfortunately, that’s wrong too. The problem is we’re still hosed if <tt>TSuperFoo</tt>’s assignment operator can also throw an exception, which is a reasonable thing to expect. If we succeed in creating our <tt>TBar</tt> objects, but <tt>TSuperFoo::operator=()</tt> fails to create whatever he needs to (presumably he’s also transactionized), the object will correctly be left untouched, but we’ll leak the new <tt>TBars</tt> we created. So the <em>right</em> answer (he said sheepishly) is this:</p>\n<pre>TFoo&amp;\nTFoo::operator=(const TFoo&amp; that)\n{\n    if (this != &amp;that) {\n        TBar* bar1 = 0;\n        TBar* bar2 = 0;\n\n        try {\n            bar1 = new TBar(*that.fBar1);\n            bar2 = new TBar(*that.fBar2);\n            TSuperFoo::operator=(that);\n        }\n        catch (...) {\n            delete bar1;\n            delete bar2;\n            throw;\n        }\n\n        delete fBar1;\n        fBar1 = bar1;\n        delete fBar2;\n        fBar2 = bar2;\n    }\n    return *this;\n}</pre>\n<p>The call to <tt>TSuperFoo::operator=()</tt> has to go inside the try. Notice that it goes <em>after</em> we create the new <tt>TBars</tt>. We want to make sure creating the <tt>TBar</tt>s has succeeded before we call <tt>TSuperFoo::operator=()</tt> because <tt>TSuperFoo::operator=()</tt> might succeed, changing the object, and we only want to change the object if we can carry out the whole assignment operation.</p>\n<p>One interesting consequence of this is that you can imagine a class with a fairly deep inheritance chain where every class up the chain has other objects it owns. You’d call an assignment operator low in the chain, it’d create the objects it needs, then it’d call its parent, which would create the objects it needs and call <em>its</em> parent, and so on up the chain. Eventually, all of the new objects would have been created and would be pointed to by temporary variables on the stack. Then, at the root level, the assignment would finally begin to be carried out, with objects being deleted and the object’s data members being changed as each function returned. So the allocations happen in one order and the assignments and deletions happen in reverse order, which feels kind of awkward at first glance, but it gets the job done. It also means that there has to be enough free memory to hold two instances of every subobject, but there really isn’t a safe way around allocating all the extra memory.</p>\n<p>By the way, I’ve also had several people question my assumption that the delete operations won’t throw exceptions. Technically they’re right, but I’d strongly counsel against letting this happen. I think it’s wise to declare \"Destructors will not throw exceptions, nor will they allow exceptions thrown by functions they call to propagate out of them\" to be a program invariant. The reason for this is that destructors are called in the course of <em>handling</em> exceptions. If exception-handling code can throw more exceptions, it’s extremely difficult, if not downright impossible, for everyone to properly clean up after himself, and extremely difficult for the program to completely recover from the error condition and go on. Therefore, throwing or propagating exceptions from within destructors is not a good idea.</p>\n<h3>The magic three</h3>\n<p>In my previous article, I singled out C++’s \"magic three\" functions, the default constructor, copy constructor and default assignment operator and said that one should always define them. This has raised a few hackles.</p>\n<p>First, several people correctly pointed out that the default constructor is only defined by the compiler when you don’t create <em>any other</em> constructors. This is indeed true; I left this fact out for simplicity. In retrospect, I shouldn’t have.</p>\n<p>Several people took exception to my statement that every class should define the \"magic three.\" They were disturbed by the suggestion that every object should have a default constructor. They’re right. There are probably more objects for which it isn’t appropriate to have a default constructor than there are for which it is. Oftentimes, you can’t initialize an object to a meaningful state without some data being supplied from outside, or you can only do it by adding special-case code just to support a default constructor you don’t really need.</p>\n<p>Occasionally, you even have a default constructor forced on you. Taligent’s CommonPoint system did this: its serialization facilities required a default consructor to work right, one of the bigger architectural gaffes in that system, in my opinion (of course, now I’ll get angry letters from ex-Taligent people explaining why it had to be that way).</p>\n<p>I think what I really meant to say in the original article didn’t come through strong enough: You should always <em>declare</em> the magic three functions. This way, you make an explicit statement that you are not accepting the default implementations of these functions. If a default constructor isn’t appropriate for your class, don’t write one just for the sake of writing one; declare it private and give it an empty implementation. But be sure you declare it. Same goes for the copy constructor and assignment operator.</p>\n<p>A number of people also suggested an improvement to my original advice: \"If you don’t want it, declare it private and give it an empty implementation.\" You actually don’t have to give an unwanted function an implementation at all. You can declare the function private and not define it. The declaration will suppress the compiler-generated version of the function, but not defining it saves you from having to supply dummy code that doesn’t actually do anything and will never get called. Furthermore, while declaring the function private will prevent outside classes from calling it, it won’t prevent <em>the same class</em> from calling it. If you don’t supply an implementation, the class will get a link error if it calls its own unwanted magic functions. This is somewhat nonintuitive to debug, but it’s better than having the compiler silently let the caller get away with calling a function nobody’s supposed to call.</p>\n<p>I also had people take rather violent exception to my suggestion that one should always define the copy constructor and assignment operator, even when they really do what you want them to do. They pointed out that it’s a lot of wasted boilerplate code, which is ugly and a pain to maintain. Furthermore, it’s possible for the compiler to perform optimizations on the default functions that it might not be able (or willing) to perform on user-written code. Most importantly, if you add or delete members from the class, the default copy constructor and assignment operator pick up the changes automatically. If you define these functions yourself, you have to remember to maintain them when the class definition changes, or you’ll have compiler errors or runtime bugs.</p>\n<p>This is all very true, but I’ll stand by my original advice just the same. Boilerplate copy constructors and assignment operators are ugly code and a hassle to maintain, but being in the habit of always writing the copy constructor and assignment operator also puts you in the habit of thinking about just what the correct copy behavior is for all the members of your class. If all the members are integers, this probably isn’t a big deal, but if they’re pointers, it’s a very big deal. Getting into the habit of accepting the defaults without taking the time to think about it can also lead to bugs down the road if you mistakenly accept the default when it <em>doesn’t</em> do the right thing.</p>\n<p>And, of course, you have to rely on comments to explain that you know about the default and are failing to define these functions <em>on purpose.</em> I’m always a little uncomfortable with relying on documentation for things like that.</p>\n<h3>Virtual assignment</h3>\n<p>Finally, several people, including my own manager here at IBM, disputed my advice to make the assignment operator of a class non-virtual. Let’s take a closer look at this issue.</p>\n<p>Consider the following simple example:</p>\n<pre>X* x;\n\nvoid setX(const X&amp; newX) {\n    x = &amp;newX;\n}</pre>\n<p>This will work right, but only if <tt>X</tt> is a monomorphic class. But let’s say <tt>X</tt> is polymorphic. Pretend it has an inheritance hierarchy like this:</p>\n<pre>  X\n / \\\nY   Z</pre>\n<p>That is…</p>\n<pre>class X {\n    // ...\n}\n\nclass Y : public X {\n   // ...\n}\n\nclass Z : public X {\n    // ...\n}</pre>\n<p>Now, if either <tt>x</tt> or <tt>newX</tt> points to an object of class <tt>Y</tt> or <tt>Z</tt>, we’ll slice. Only the members defined in <tt>X</tt> will get copied. If <tt>x</tt> is an instance of <tt>Y</tt> or <tt>Z</tt>, the members defined by <tt>Y</tt> or <tt>Z</tt> won’t get led in with new values. If <tt>newX</tt> is an instance of <tt>Y</tt> or <tt>Z</tt>, the members defined by <tt>Y</tt> or <tt>Z</tt> won’t get copied into <tt>x</tt>. Bad news.</p>\n<p>The problem here, of course, is that we’re calling <tt>X</tt>’s assignment operator even when <tt>x</tt> isn’t an instance of <tt>X</tt>. The obvious solution, therefore, would be to make <tt>X</tt>’s assignment operator virtual. Then the correct assignment operator would be called. If we do this, the assignment operators would look like this:</p>\n<pre>X&amp; X::operator=(const X&amp; that) {\n    // copy X’s members...\n    return *this;\n}\n\nX&amp; Y::operator=(const X&amp; that) {\n    Y&amp; y = dynamic_cast&lt;Y&amp;&gt;(that);\n\n    X::operator=(that);\n    // copy Y’s members using y\n    return *this;\n}\n\nX&amp; Z::operator=(const X&amp; that) {\n    Z&amp; z = dynamic_cast&lt;Z&amp;&gt;(that);\n\n    X::operator=(that);\n    // copy Z’s members using z\n    return *this;\n}</pre>\n<p>Now, if <tt>x</tt> and <tt>newX</tt> are actually both instances of <tt>Y</tt>, <tt>Y</tt>’s assignment operator will get called and everybody will work right. Big improvement, right?</p>\n<p>Well, consider the situation where <tt>x</tt> is a <tt>Y</tt> and <tt>newX</tt> is a <tt>Z</tt>. In this case, the <tt>dynamic_cast</tt> will fail, throwing a <tt>bad_cast</tt> exception. Now we have a problem.</p>\n<p>The <tt>bad_cast</tt> exception is good, in a way, because it traps the mismatched classes and causes an error, rather than just slicing silently. But now we have an error condition we have to handle.</p>\n<p>Remember that after an assignment succeeds, the objects on either side of the <tt>=</tt> are to be computationally equivalent. That is, all of their visible state and their behavior should be the same. This implies that they should be the same class. What you really want is for it to look like <tt>x</tt> morphed from whatever class it was to the same class <tt>newX</tt> is. <tt>X</tt>, <tt>Y</tt>, and <tt>Z</tt>’s assignment operators can’t do this; there’s no way to morph an existing object from one class to another (well, there kind of is, but we’ll get to it later). Instead, <tt>setX()</tt> has to deal with this:</p>\n<pre>void setX(const X&amp; newX) {\n    try {\n        x = &amp;newX;\n    }\n    catch (bad_cast&amp;) {\n        X* temp = newX.clone();\n        delete x;\n        x = temp;\n    }\n}</pre>\n<p>Remember <tt>clone()</tt>? This is the polymorphic copy constructor. If you need polymorphic copy on a group of related classes, you define a virtual function called <tt>clone()</tt> and every class in the tree overrides it to call his own copy constructor. You can’t just call <tt>X</tt>’s copy constructor for the same reason you can’t just call <tt>X</tt>’s assignment operator.</p>\n<p>Another alternative is that <tt>setX()</tt> doesn’t handle this condition, but some other class up the inheritance chain will have to, probably by doing the same thing we’re doing here: deleting the old <tt>X</tt> and creating a new one of the right class. (There might be other meaningful ways of handling the exception, but they’d be more application-specific.)</p>\n<p>The other possibility is that <em>nobody</em> handles the exception. We could just declare \"assignment operators shall always be called with like classes on either side of the equal sign\" as a program invariant. In other words, we declare heterogeneous assignment to be a condition which Should Never Happen.</p>\n<p>Violations of program invariants (\"Should Never Happen\" conditions) are programmer errors; they’re things you’re assuming you’ll never run into at runtime. An exception shouldn’t be thrown for a violated invariant; since you’re not expecting it to happen at runtime, you don’t want to waste time putting in lots of extra code to handle it; the program is just malformed. And if you throw an exception that nobody catches, this simply causes your program to terminate. Quietly. With no error messages.</p>\n<p>If your program’s going to terminate, you want it to terminate loudly, proclaiming to the world that Something Went Wrong. The way you do this is with the <tt>assert()</tt> macro. You pass to <tt>assert()</tt> an expression you expect to always evaluate to <tt>true</tt>. If it evaluates to <tt>false</tt>, it prints an error message that usually contains the text of the offending expression and the line number of the assert, and then the program terminates. (You can also cause asserts to be compiled out in production versions of your program, which will cause them to fail silently instead.)</p>\n<p>So then instead of the dynamic cast, you can do a static cast and precede it with an assert:</p>\n<pre>X&amp; Y::operator=(const X&amp; that) {\n    assert(typeid(that) == typeid(*this));\n\n    Y&amp; y = static_cast&lt;Y&amp;&gt;(that);\n    X::operator=(that);\n    // copy Y’s members using y\n    return *this;\n}</pre>\n<p>By the way, my original attempt at this was</p>\n<pre>assert(typeid(that) == typeid(Y));</pre>\n<p>You don’t want to do it this way, because then when <tt>Y::operator=()</tt> calls <tt>X::operator=()</tt>, <tt>X::operator=()</tt> will choke because <tt>that</tt> isn’t an instance of <tt>X</tt>. You’re not concerned that \"that\" is some particular static type; you’re concerned that \"this\" and \"that\" are the <em>same</em> type, whatever that type is.</p>\n<p>So anyway, using the assert is one way around the heterogeneous-assignment problem, and it has a lot to recommend it, in situations where you really know that this invariant can hold.</p>\n<p>But let’s go back to the previous answer for a minute and assume we’re going to catch the exception and finagle the assignment in <tt>setX()</tt>. To refresh our memory, <tt>setX()</tt> now looks like this:</p>\n<pre>void setX(const X&amp; newX) {\n    try {\n        x = &amp;newX;\n    }\n    catch (bad_cast&amp;) {\n        X* temp = newX.clone();\n        delete x;\n        x = temp;\n    }\n}</pre>\n<p>Let’s consider our possibilities here, ignoring <tt>Z</tt> for a moment. If <tt>x</tt> and <tt>newX</tt> are both instances of <tt>X</tt> or both instances of <tt>Y</tt>, we’re cool. If <tt>x</tt> is an instance of <tt>Y</tt> and <tt>newX</tt> is an instance of <tt>X</tt>, we’re also cool. <tt>Y::operator=()</tt> with throw a <tt>bad_cast</tt> exception, and we’ll catch it, delete <tt>x</tt>, and new up a fresh new <tt>Y</tt> to assign to <tt>x</tt>.</p>\n<p>But what if <tt>x</tt> is an instance of <tt>X</tt> and <tt>newX</tt> is an instance of <tt>Y</tt>? In this case, we’ll end up in <tt>X</tt>’s assignment operator, and the dynamic cast will <em>succeed.</em> <tt>Y</tt> is a subclass of <tt>X</tt>, so dynamically casting a reference to a <tt>Y</tt> to a reference to an <tt>X</tt> is legal. Every <tt>Y</tt> is also an <tt>X</tt>. But because we’re in X’s assignment operator, we’ll only copy over the members of <tt>newX</tt> that were defined in <tt>X</tt>. It’s our old friend slicing again.</p>\n<p>What we’d have to do to avoid this is manually check for like class in each assignment operator and throw the <tt>bad_cast</tt> ourselves, rather than relying on <tt>dynamic_cast</tt> to do it for us.</p>\n<p>Instead, my original solution to this problem was to avoid using the assignment operator in the first place:</p>\n<pre>void setX(const X&amp; newX) {\n    X* temp = newX.clone();\n    delete x;\n    x = temp;\n}</pre>\n<p>I still like this. It’s simple and clear, and it works correctly with no extra hassles even when <tt>x</tt> and <tt>newX</tt> are instances of different classes. The other solution, with the try/catch blocks, has an advantage in situations where the cost of deleting and newing the destination object is large and relatively rare (the try costs nothing in most modern compilers, so you in effect fast-path the case of like classes, but an actual throw can be quite expensive, so you achieve this fast-path effect at the expense of the different-classes case).</p>\n<p>If the fast-path option makes sense for your application, I’d suggest avoiding the exception and doing it yourself like this:</p>\n<pre>void setX(const X&amp; newX) {\n    if (typeid(*x) == typeid(newX))\n        x = newX;\n    else {\n        X* temp = newX.clone();\n        delete x;\n        x = temp;\n    }\n}</pre>\n<p>Now if you avoid using the assignment operator in situations where slicing may be a problem, we’re still left with the question of whether it makes more sense to make the assignment operator virtual or non-virtual. I’m tending now to come down on the side of making the assignment operator virtual with an assert to check for the different-classes condition (since there’s no way to handle that in the assignment operator itself and therefore the calling function already has to be aware of the possibility of polymorphism and handle it).</p>\n<p>However, there’s another problem here. I remembered Taligent’s coding guidelines discouraging virtual assignment operators, so I went back to see why it recommended that. I wish I had done that before. It turns out Taligent’s guidelines weren’t hard and fast on the subject. Instead they point out that defining</p>\n<pre>virtual X&amp; Y::operator=(const X&amp; that);</pre>\n<p>won’t keep the compiler from defining</p>\n<pre>Y&amp; Y::operator=(const Y&amp; that);</pre>\n<p>In other words, an override of an inherited assignment operator doesn’t suppress the compiler-generated default assignment operator. You’d still have to do that manually by declaring it private and not giving it an implementation.</p>\n<p>And actually, this won’t even work because C++’s overload resolution rules will cause the suppressed version to win in some types of call. For instance, consider a class like this:</p>\n<pre>class Y : public X {\n    public:\n        virtual X&amp; operator=(const X&amp; that);\n        // other method definitions…\n    private:\n        Y&amp; operator=(const Y&amp; that);\n}</pre>\n<p>Now consider this code snippet:</p>\n<pre>Y someY(/*agruments*/);\n// do something with someY\nY someOtherY(/*arguments*/);\nsomeY = someOtherY;</pre>\n<p>Since both <tt>someY</tt> and <tt>someOtherY</tt> are instances of <tt>Y</tt>, the overload resolution rules will declare the nonvirtual version of <tt>operator=()</tt> to be the \"winner,\" instead of the inherited virtual <tt>operator=()</tt>. Since the nonvirtual <tt>operator=()</tt> is private, you’ll get an access-violation error at compile time.</p>\n<p>Instead, you’d have to define the default assignment operator to call the virtual one. In every class that inherits the virtual one. Of course, this means defining it non-virtual. To see why, imagine if <tt>Y</tt> in the above example had a subclass called <tt>Z</tt>. If <tt>Y</tt>’s <tt>operator=()</tt> was virtual, <tt>Z</tt> would have to override it, then it would have to override <tt>X</tt>’s <tt>operator=()</tt>, and then it would have to replace its own default assignment operator. Cutting any corners here risks creating situations where the \"winning\" function, according to the overload-resolution rules, is a function that is not accessible or isn’t implemented. Clearly, this gets ridiculous quickly as the inheritance hierarchy gets deeper.</p>\n<p>One side effect in either case is that you have to define an override of the virtual <tt>operator=()</tt> even when you don’t strictly need one; otherwise, the \"default\" one will hide the virtual one.</p>\n<p>So there you go. A truly foolproof method of handling polymorphism in assignment operators involves declaring <em>both</em> a virtual <em>and</em> a non-virtual assignment operator in every class (except the root class of each inheritance hierarchy), with the non-virtual calling the virtual and the virtual asserting that both objects involved are the same class. Any time a calling function couldn’t guarantee the invariant would hold, it would have to avoid using the assignment operator and manually delete the object referenced by the target variable and new up a new one of the proper type.</p>\n<p>Beautiful, huh?</p>\n<h3>Other ways of morphing</h3>\n<p>Before I wrap this up, one more thing: I alluded earlier to the idea that there are ways of making an object look like it’s morphed from one class to another. There are two ways to do this, neither of which is really all that much of a winner.</p>\n<p>One option is <em>not</em> to change the class of the object on the left-hand side. It’s perfectly reasonable to define assignment operators that take different types on the left and right-hand side. The operator in this case performs some kind of meaningful conversion of the incoming data as part of the assignment process. The result isn’t really a copy, but it may produce completely appropriate results. This solution is definitely the right way to go for some classes in some applications, but it’s not a general solution. Be sure to consider whether it’s appropriate for your classes before going to all the trouble above.</p>\n<p>The other option is to fake inheritance using containment. In this case, the objects on the left and right-hand sides of the equal sign <em>are</em> the same class, but they behave like members of different classes because they own objects of different classes. The simplest version of this idea is a smart pointer that knows about polymorphism for a certain group of classes and does the right thing. All you’re really doing here is encapsulating in this object’s assignment operator the delete/new code you’d otherwise have to put in client code, but hiding junk like this in a smart-pointer class is very often a useful and effective way to go. (This is the essence of the State pattern, by the way.)</p>\n<h3>Conclusion</h3>\n<p>I don’t know about you, but there’s something really scary to me about a language where copying state from one object to another is this complicated. By now, I suspect at least a dozen or two programmers have contributed something new to this discussion. If it takes this many programmers to write a simple assignment operator, think how complicated writing code that actually does something meaningful must be!</p>\n<p>The devil truly is in the details, especially in C++ programming.</p>\n<p>I’m sure there are still other issues, both with the original article and this one, that I’ve missed. I’ve learned a lot about this, and I’m interested in continuing to lean. Keep those cards and letters coming!</p>\n<p align=\"center\"><small>&nbsp;</small></p>\n<p>END</p>","excerpt":"by Richard Gillam Senior Software Engineer, Text & International Taligent, Inc. My team recently hired someone. Normally, this wouldn't be such a big deal, but…","frontmatter":{"date":"17 September, 2013","path":"/blog/2013-09-17-the-anatomy-of-the-assignment-operator/","title":"The Anatomy of the Assignment Operator =()"},"fields":{"readingTime":{"text":"56 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}