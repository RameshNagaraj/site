{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2013-09-26-stack-unwinding/","result":{"data":{"markdownRemark":{"html":"<p><strong>Definition</strong>: As you create objects statically (on the stack as opposed to allocating them in the heap memory) and perform function calls, they are \"stacked up\".</p>\n<p>When a scope (anything delimited by <code class=\"language-text\">{</code> and <code class=\"language-text\">}</code>) is exited (by using <code class=\"language-text\">return XXX;</code>, reaching the end of the scope or throwing an exception) everything within that scope is destroyed (destructors are called for everything). <strong>This process of destroying local objects and calling destructors is called stack unwinding.</strong> (Exiting a code block using <code class=\"language-text\">goto</code> will not unwind the stack which is one of the reasons you should never use <code class=\"language-text\">goto</code> in C++).</p>\n<p>You have the following issues related to stack unwinding:</p>\n<ol>\n<li>avoiding memory leaks (anything dynamically allocated that is not managed by a local object and cleaned up in the destructor will be leaked) - see RAII <a href=\"http://stackoverflow.com/questions/2331316/what-is-stack-unwinding/2331413#2331413\">referred to</a> by Nikolai, and <a href=\"http://www.boost.org/doc/libs/1_41_0/libs/smart_ptr/scoped_ptr.htm\">the documentation for boost::scoped_ptr</a> or this example of using <a href=\"http://www.google.com/codesearch/p?hl=en#so90T49b54s/przyklady/cpprec.zip%7Cg3JV5CE7tsM/12-02.cpp&#x26;q=mutex%3a%3ascoped_lock\">boost::mutex::scoped_lock</a>.</li>\n<li>program consistency: the C++ specifications state that you should never throw an exception before any existing exception has been handled. This means that <strong>the stack unwinding process should never throw an exception</strong> (either use only code guaranteed not to throw in destructors, or surround everything in destructors with <code class=\"language-text\">try {</code> and <code class=\"language-text\">} catch(...) {}</code>).</li>\n</ol>\n<p>If any destructor throws an exception during stack unwinding you end up in the <em>land of undefined behavior</em> which could cause your program to treminate unexpectedly (most common behavior) or the universe to end (theoretically possible but has not been observed in practice yet).</p>\n<p>END</p>","excerpt":"Definition: As you create objects statically (on the stack as opposed to allocating them in the heap memory) and perform function calls, they are \"stacked upâ€¦","frontmatter":{"date":"26 September, 2013","path":"/blog/2013-09-26-stack-unwinding/","title":"Stack Unwinding"},"fields":{"readingTime":{"text":"2 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}