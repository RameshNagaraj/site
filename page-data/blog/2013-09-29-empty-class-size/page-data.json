{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2013-09-29-empty-class-size/","result":{"data":{"markdownRemark":{"html":"<h2><a name=\"sizeof-empty\"></a>Why is the size of an empty class not zero?</h2>\n<p>To ensure that the addresses of two different objects will be different. For the same reason, \"new\" always returns pointers to distinct objects. Consider:</p>\n<pre>\tclass Empty { };\n\n\tvoid f()\n\t{\n\t\tEmpty a, b;\n\t\tif (&amp;a == &amp;b) cout &lt;&lt; \"impossible: report error to compiler supplier\";\n\n\t\tEmpty* p1 = new Empty;\n\t\tEmpty* p2 = new Empty;\n\t\tif (p1 == p2) cout &lt;&lt; \"impossible: report error to compiler supplier\";\n\t}</pre>\n<p>There is an interesting rule that says that an empty base class need not be represented by a separate byte:</p>\n<pre>\tstruct X : Empty {\n\t\tint a;\n\t\t// ...\n\t};\n\n\tvoid f(X* p)\n\t{\n\t\tvoid* p1 = p;\n\t\tvoid* p2 = &amp;p-&gt;a;\n\t\tif (p1 == p2) cout &lt;&lt; \"nice: good optimizer\";\n\t}</pre>\n<p>This optimization is safe and can be most useful. It allows a programmer to use empty classes to represent very simple concepts without overhead. Some current compilers provide this \"empty base class optimization\".</p>\n<p>Size of an empty class is not zero. It is 1 byte generally. It is nonzero to ensure that the two different objects will have different addresses.</p>\n<div>\n<div id=\"highlighter_581795\">\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody>\n<tr>\n<td>\n<div>\n<div><code>#include&lt;iostream&gt;</code></div>\n<div><code>using</code> <code>namespace</code> <code>std;</code></div>\n<div></div>\n<div><code>class</code> <code>Empty { };</code></div>\n<div></div>\n<div><code>int</code> <code>main()</code></div>\n<div><code>{</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Empty a, b;</code></div>\n<div></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(&amp;a == &amp;b)</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cout &lt;&lt; </code><code>\"impossible \"</code> <code>&lt;&lt; endl;</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cout &lt;&lt; </code><code>\"Fine \"</code> <code>&lt;&lt; endl;</code></div>\n<div></div>\n<div><code>&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>0;</code></div>\n<div><code>}</code></div>\n</div>\n</td>\n</tr>\n</tbody>\n</table>\n</div>\n</div>\n<p>Output:</p>\n<pre>Fine</pre>\n<p>For the same reason (different objects should have different addresses), “new” always returns pointers to distinct objects. See the following example.</p>\n<div>\n<div id=\"highlighter_579980\">\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody>\n<tr>\n<td>\n<div>\n<div><code>#include&lt;iostream&gt;</code></div>\n<div><code>using</code> <code>namespace</code> <code>std;</code></div>\n<div></div>\n<div><code>class</code> <code>Empty { };</code></div>\n<div></div>\n<div><code>int</code> <code>main()</code></div>\n<div><code>{</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Empty* p1 = </code><code>new</code> <code>Empty;</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Empty* p2 = </code><code>new</code> <code>Empty;</code></div>\n<div></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(p1 == p2)</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cout &lt;&lt; </code><code>\"impossible \"</code> <code>&lt;&lt; endl;</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cout &lt;&lt; </code><code>\"Fine \"</code> <code>&lt;&lt; endl;</code></div>\n<div></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>0;</code></div>\n<div><code>}</code></div>\n</div>\n</td>\n</tr>\n</tbody>\n</table>\n</div>\n</div>\n<p>Output:</p>\n<pre>Fine</pre>\n<p>Now guess the output of following program (This is tricky)</p>\n<div>\n<div id=\"highlighter_990124\">\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody>\n<tr>\n<td>\n<div>\n<div><code>#include&lt;iostream&gt;</code></div>\n<div><code>using</code> <code>namespace</code> <code>std;</code></div>\n<div></div>\n<div><code>class</code> <code>Empty { };</code></div>\n<div></div>\n<div><code>class</code> <code>Derived: Empty { </code><code>int</code> <code>a; };</code></div>\n<div></div>\n<div><code>int</code> <code>main()</code></div>\n<div><code>{</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cout &lt;&lt; </code><code>sizeof</code><code>(Derived);</code></div>\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>0;</code></div>\n<div><code>}</code></div>\n</div>\n</td>\n</tr>\n</tbody>\n</table>\n</div>\n</div>\n<p>Output (with GCC compiler. See <a href=\"http://ideone.com/JFoX8\">this</a>):</p>\n<pre>4</pre>\n<p>Note that the output is not greater than 4. There is an interesting rule that says that an empty base class need not be represented by a separate byte. So compilers are free to make optimization in case of empty base classes.</p>\n<p> </p>\n<p>The size of the empty class is always ONE and not ZERO. This is because of below reasons</p>\n<ol>\n<li>Every object should have some address location to identify, independent of the no.of member variables in the class. Generally the size of the object is the sum of the member variables in the class. if no data is there, one byte of memory allocated to the object to identify. this will help to not conflicting with other empty objects.</li>\n<li>One more <strong>logical</strong> reason is that Some times we will use the sizeof() operator in division operation like X%<em>sizeof</em>(emptyclass) and if the value of empty class is zero , application/program will crash.</li>\n</ol>\n<p>END</p>","excerpt":"Why is the size of an empty class not zero? To ensure that the addresses of two different objects will be different. For the same reason, \"new\" always returns…","frontmatter":{"date":"28 September, 2013","path":"/blog/2013-09-29-empty-class-size/","title":"Empty Class Size"},"fields":{"readingTime":{"text":"3 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}