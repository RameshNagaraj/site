{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2013-09-29-placement-new/","result":{"data":{"markdownRemark":{"html":"<p>There are many uses of placement <tt>new</tt>. The simplest use is to place an object at a particular location in memory. This is done by supplying the place as a pointer parameter to the <tt>new</tt> part of a <tt>new</tt> expression:</p>\n<pre>#include &lt;new&gt;        // <em>Must <tt>#include</tt> this to use \"placement <tt>new</tt>\"</em>\n#include \"Fred.h\"     // <em>Declaration of <tt>class</tt> <tt>Fred</tt></em>\n\nvoid someCode()\n{\n  char memory[sizeof(Fred)];     // <em>Line #1</em>\n  void* place = memory;          // <em>Line #2</em>\n\n  Fred* f = new(place) Fred();   // <em>Line #3 (see \"DANGER\" below)</em>\n  // <em>The pointers <tt>f</tt> and <tt>place</tt> will be equal</em>\n\n  <em>...</em>\n}</pre>\n<p>Line #1 creates an array of <tt>sizeof(Fred)</tt> bytes of memory, which is big enough to hold a <tt>Fred</tt> object. Line #2 creates a pointer <tt>place</tt> that points to the first byte of this memory (experienced C programmers will note that this step was unnecessary; it's there only to make the code more obvious). Line #3 essentially just calls the constructor <tt>Fred::Fred()</tt>. The <tt>this</tt> pointer in the <tt>Fred</tt> constructor will be equal to <tt>place</tt>. The returned pointer <tt>f</tt> will therefore be equal to <tt>place</tt>.</p>\n<p><em>ADVICE:</em> Don't use this \"placement <tt>new</tt>\" syntax unless you have to. Use it only when you really care that an object is placed at a particular location in memory. For example, when your hardware has a memory-mapped I/O timer device, and you want to place a <tt>Clock</tt> object at that memory location.</p>\n<p><em>DANGER:</em> You are taking <em>sole</em> responsibility that the pointer you pass to the \"placement <tt>new</tt>\" <tt>operator</tt> points to a region of memory that is big enough and is properly aligned for the object type that you're creating. Neither the compiler nor the run-time system make any attempt to check whether you did this right. If your <tt>Fred</tt> class needs to be aligned on a 4 byte boundary but you supplied a location that isn't properly aligned, you can have a serious disaster on your hands (if you don't know what \"alignment\" means, <em>please</em> don't use the placement <tt>new</tt> syntax). You have been warned.</p>\n<p>You are also solely responsible for destructing the placed object. This is done by explicitly calling the destructor:</p>\n<pre>void someCode()\n{\n  char memory[sizeof(Fred)];\n  void* p = memory;\n  Fred* f = new(p) Fred();\n  <em>...</em>\n  f-&gt;~Fred();   // <em>Explicitly call the destructor for the placed object</em>\n}</pre>\n<p>This is about the only time you ever explicitly call a destructor.</p>\n<p><strong>What is <em>placement new</em> in C++?</strong></p>\n<ul>\n<li>In some scenarios it becomes necessary to place objects at specified locations in memory. Placement new solves this problem.</li>\n<li>For example, there could be predefined memory pools in which certain objects need to be placed on creation.</li>\n<li>Placement new is achieved by overloading the new operator which takes more than one argument apart from the default size_t argument.</li>\n</ul>\n<p>EXAMPLE: Demonstrate the usage of placement new</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">#include &amp;lt;iostream&amp;gt;\nusing namespace std;\n\nclass MyClass {\n\n   public:\n\n    // Placement new operator\n    void* operator new (size_t sz, void* v) {\n        cout &amp;lt;&amp;lt; &quot;Placement new invoked&quot; &amp;lt;&amp;lt; endl;\n        return v;\n    }\n\n    ~MyClass() {\n        // Cleanup\n    }\n};\n\nint main()\n{\n    // Create a buffer to store the object\n    int buffer[16];\n    cout &amp;lt;&amp;lt; &quot;Starting address of my buffer = &quot; &amp;lt;&amp;lt; &amp;amp;buffer &amp;lt;&amp;lt; endl;\n\n    // Create the object. Use placement new\n    MyClass* obj = new (buffer) MyClass();\n    cout &amp;lt;&amp;lt; &quot;Location of my object = &quot; &amp;lt;&amp;lt; obj &amp;lt;&amp;lt; endl;\n\n    // Don&#39;t delete object created with placement delete\n    // Call the destructor explicitly\n    obj-&amp;gt;~MyClass();\n}\n\nOUTPUT:\nStarting address of my buffer = 0012FF4C\nPlacement new invoked\nLocation of my object = 0012FF4C</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p> </p>\n<p><a href=\"http://blog.aaronballman.com/2011/08/the-placement-new-operator/\">http://blog.aaronballman.com/2011/08/the-placement-new-operator/</a></p>\n<p>END</p>","excerpt":"There are many uses of placement new. The simplest use is to place an object at a particular location in memory. This is done by supplying the place as a…","frontmatter":{"date":"28 September, 2013","path":"/blog/2013-09-29-placement-new/","title":"Placement new"},"fields":{"readingTime":{"text":"3 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}