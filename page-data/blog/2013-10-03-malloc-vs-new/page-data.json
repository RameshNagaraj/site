{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2013-10-03-malloc-vs-new/","result":{"data":{"markdownRemark":{"html":"<p>From the <a href=\"http://yosefk.com/c++fqa/heap.html#fqa-16.4\">C++ FQA Lite</a>:</p>\n<blockquote>\n<p>\n[16.4] Why should I use new instead of trustworthy old malloc()?</p>\n<p>FAQ: new/delete call the constructor/destructor; new is type safe, malloc is not; new can be overridden by a class.</p>\n<p>FQA: The virtues of new mentioned by the FAQ are not virtues, because constructors, destructors, and operator overloading are garbage (see what happens when you have no garbage collection?), and the type safety issue is really tiny here (normally you have to cast the void* returned by malloc to the right pointer type to assign it to a typed pointer variable, which may be annoying, but far from \"unsafe\").</p>\n<p>Oh, and using trustworthy old malloc makes it possible to use the equally trustworthy &#x26; old realloc. Too bad we don't have a shiny new operator renew or something.</p>\n<p>Still, new is not bad enough to justify a deviation from the common style used throughout a language, even when the language is C++. In particular, classes with non-trivial constructors will misbehave in fatal ways if you simply malloc the objects. So why not use new throughout the code? People rarely overload operator new, so it probably won't get in your way too much. And if they do overload new, you can always ask them to stop.</p>\n</blockquote>\n<ol>\n<li>Operator new constructs an object (calls constructor of object), malloc does not.</li>\n<li>Operator new is an operator, malloc is a function.</li>\n<li>Operator new can be overloaded, malloc cannot be overloaded.</li>\n<li>Operator new throws an exception if there is not enough memory, malloc returns a NULL.</li>\n<li>Operator new[] requires to specify the number of objects to allocate, malloc requires to specify the total number of bytes to allocate.</li>\n<li>malloc() returns void *, which has to be explicitly cast to the desired type but new returns the proper type.</li>\n<li>Operator new/new[] must be matched with operator delete/delete[] to deallocate memory, malloc() must be matched with free() to deallocate memory.</li>\n<li>The new/delete couple does not have a realloc alternative that is available when malloc/free pair is used. realloc is used to resize the length of an array or a memory block dynamically</li>\n</ol>\n<h2>Deficiencies fixed by new for C++ code</h2>\n<ol>\n<li>\n<p><code class=\"language-text\">malloc</code> is not typesafe in any meaningful way. In C++ you are required to cast the return from<code class=\"language-text\">void*</code>. This potentially introduces a lot of problems:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">#include &amp;lt;stdlib.h&amp;gt;\n\nstruct foo {\n  double d[5];\n}; \n\nint main() {\n  foo *f1 = malloc(1); // error, no cast\n  foo *f2 = static_cast&amp;lt;foo*&amp;gt;(malloc(sizeof(foo)));\n  foo *f3 = static_cast&amp;lt;foo*&amp;gt;(malloc(1)); // No error, bad\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>It's worse than that though. If the type in question is <a href=\"http://stackoverflow.com/questions/146452/what-are-pod-types-in-c\">POD (plain old data)</a> then you can semi-sensibly use <code class=\"language-text\">malloc</code> to allocate memory for it, as <code class=\"language-text\">f2</code> does in the first example.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">It&#39;s not so obvious though if a type is POD. The fact that it&#39;s possible for a given type to change from POD to non-POD with no resulting compiler error and potentially very hard to debug problems is a significant factor. For example if someone (possibly another programmer, during maintenance, much later on were to make a change that caused&amp;nbsp;`` foo ``&amp;nbsp;to no longer be POD then no obvious error would appear at compile time as you&#39;d hope, e.g.:\n\n\n\n    struct foo {\n      double d[5];\n      virtual ~foo() { }\n    };\n\n\n\nwould make the&amp;nbsp;`` malloc ``&amp;nbsp;of&amp;nbsp;`` f2 ``&amp;nbsp;also become bad, without any obvious diagnostics. The example here is trivial, but it&#39;s possible to accidentally introduce non-PODness much further away (e.g. in a base class, by adding a non-POD member). If you have C++11/boost you can use&amp;nbsp;`` is_pod ``&amp;nbsp;to check that this assumption is correct and produce an error if it&#39;s not:\n\n\n\n    #include &amp;lt;type_traits&amp;gt;\n    #include &amp;lt;stdlib.h&amp;gt;\n    \n    foo *safe_foo_malloc() {\n      static_assert(std::is_pod&amp;lt;foo&amp;gt;::value, &quot;foo must be POD&quot;);\n      return static_cast&amp;lt;foo*&amp;gt;(malloc(sizeof(foo)));\n    }\n\n\n\nAlthough boost is&amp;nbsp;[unable to determine if a type is POD](http://www.boost.org/doc/libs/1_47_0/libs/type_traits/doc/html/boost_typetraits/reference/is_pod.html)&amp;nbsp;without C++11 or some other compiler extensions.</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ol start=\"3\">\n<li>\n<p><code class=\"language-text\">malloc</code> returns <code class=\"language-text\">NULL</code> if allocation fails. <code class=\"language-text\">new</code> will throw <code class=\"language-text\">std::bad_alloc</code>. The behaviour of later using a <code class=\"language-text\">NULL</code> pointer is undefined. An exception has clean semantics when it is thrown and it is thrown from the source of the error. Wrapping <code class=\"language-text\">malloc</code> with an appropriate test at every call seems tedious and error prone. (You only have to forget once to undo all that good work). An exception can be allowed to propagate to a level where a caller is able to sensibly process it, where as <code class=\"language-text\">NULL</code> is much harder to pass back meaningfully. We could extend our <code class=\"language-text\">safe_foo_malloc</code>function to throw an exception or exit the program or call some handler:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">#include &amp;lt;type_traits&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n\nvoid my_malloc_failed_handler();\n\nfoo *safe_foo_malloc() {\n  static_assert(std::is_pod&amp;lt;foo&amp;gt;::value, &quot;foo must be POD&quot;);\n  foo *mem = static_cast&amp;lt;foo*&amp;gt;(malloc(sizeof(foo)));\n  if (!mem) {\n     my_malloc_failed_handler();\n     // or throw ...\n  }\n  return mem;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p>Fundamentally <code class=\"language-text\">malloc</code> is a C feature and <code class=\"language-text\">new</code> is a C++ feature. As a result <code class=\"language-text\">malloc</code> does not play nicely with constructors, it only looks at allocating a chunk of bytes. We could extend our<code class=\"language-text\">safe_foo_malloc</code> further to use placement <code class=\"language-text\">new</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">#include &amp;lt;stdlib.h&amp;gt;\n#include &amp;lt;new&amp;gt;\n\nvoid my_malloc_failed_handler();\n\nfoo *safe_foo_malloc() {\n  void *mem = malloc(sizeof(foo));\n  if (!mem) {\n     my_malloc_failed_handler();\n     // or throw ...\n  }\n  return new (mem)foo();\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p>Our <code class=\"language-text\">safe_foo_malloc</code> function isn't very generic - ideally we'd want something that can handle any type, not just <code class=\"language-text\">foo</code>. We can achieve this with templates and variadic templates for non-default constructors:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">#include &amp;lt;functional&amp;gt;\n#include &amp;lt;new&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n\nvoid my_malloc_failed_handler();\n\ntemplate &amp;lt;typename T&amp;gt;\nstruct alloc {\n  template &amp;lt;typename ...Args&amp;gt;\n  static T *safe_malloc(Args&amp;amp;&amp;amp;... args) {\n    void *mem = malloc(sizeof(T));\n    if (!mem) {\n       my_malloc_failed_handler();\n       // or throw ...\n    }\n    return new (mem)T(std::forward(args)...);\n  }\n};</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Now though in fixing all the issues we identified so far we&#39;ve practically reinvented the default&amp;nbsp;`` new ``operator. If you&#39;re going to use&amp;nbsp;`` malloc ``&amp;nbsp;and placement&amp;nbsp;`` new ``&amp;nbsp;then you might as well just use&amp;nbsp;`` new ``to begin with!</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><span style=\"font-style:inherit;line-height:1.625;\">END</span></p>","excerpt":"From the C++ FQA Lite:  \n[16.4] Why should I use new instead of trustworthy old malloc()? FAQ: new/delete call the constructor/destructor; new is type safe…","frontmatter":{"date":"02 October, 2013","path":"/blog/2013-10-03-malloc-vs-new/","title":"malloc vs new"},"fields":{"readingTime":{"text":"5 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}