{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2013-11-04-trie-spell-checking-with-tries-in-c/","result":{"data":{"markdownRemark":{"html":"<h3>Spell checking with tries in C++: Part 1</h3>\n<p><a href=\"http://en.wikipedia.org/wiki/Trie\">Tries</a> are a really cool data structure used for storing strings (and potentially other things) efficiently and compactly. They can have speed and space advantages over trees for and hash tables when used as associative arrays, but the linked nature of tries lets you do other cool things with them. As an example, let’s write a spell-checker in C++.</p>\n<p>A trie (<em>technically</em> pronounced “tree”, but commonly “try”) is basically just a special kind tree. Generally speaking, each node in the trie can have any number of children, but for our purposes, we’ll say that each node has 26 slots for children, one for each letter of the alphabet.</p>\n<p>Each node in the trie represents some string. Starting from the root of the tree, any path to any other node will go over edges labeled by letters of the alphabet. The sequence of letters you pass through to get to the node in question tell you what string is associated with that node. For example, starting from the root, if you take a ‘c’ edge, then an ‘a’ edge, and then a ‘t’ edge, the node you end up at represents the string “cat”.</p>\n<p>Each node also has a <code class=\"language-text\">final</code> property, intended to indicate whether we want to actually count that word as part of the trie. For example, in the “cat” trie above, “c” and “ca” are also strings stored by the trie. If we want to make it so that only “cat” (and not “ca” or “c”) should be considered part of our trie, we’ll set the “cat” node be final, and set the “c” and “ca” nodes to not final.</p>\n<p>From this description, searching for a string in a trie is easy. If we have a particular string, all we need to do is follow the edges in the trie that correspond to the letters of the string. If we end up at a final node, the string is stored by the trie. If the node we get to is not final, or if we hit a null node along the way, then the string isn’t stored by the trie.</p>\n<h4>Coding the Trie</h4>\n<p>So fire up your text editor and get coding. The first thing we’ll need is a <code class=\"language-text\">Node</code> class (which will end up being embedded in the <code class=\"language-text\">trie</code> class). The skeleton for the <code class=\"language-text\">Node</code>class looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">struct Node\n{\n  Node* children[26];\n  bool final;\n};</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Simple enough. We have our 26 children and our final property. Now we just initialize stuff with a constructor:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Node() : final(false)\n{\n  for(int i = 0;i &amp;lt; 26;++i)\n    children[i] = 0; //ie, NULL\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>We also need a destructor for memory cleanup (technically we’d also want a copy constructor, but we’ll be careful about not passing tries by value)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">~Node()\n{\n  for(int i = 0;i &amp;lt; 26;++i)\n    if(children[i]) delete children[i];\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>We’ll also make a method that makes accessing the<code class=\"language-text\">children</code> array easier:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Node*&amp;amp; child(char c)\n{\n  return children[tolower(c)-&#39;a&#39;];\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This method converts all characters to lowercase (using the <code class=\"language-text\">tolower</code> function found in <code class=\"language-text\">cctype</code>) so we don’t need to worry about the case of the strings we index/search. Note that it also returns a reference, so we can modify the contents of <code class=\"language-text\">children</code> via this method (which is what we want, <code class=\"language-text\">child</code> is just a convenience access method).</p>\n<p>Now, onto the class for the trie itself:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class Trie\n{\n  public:\n    struct Node\n    {\n      //...\n    };\n\n    Trie()\n    {\n      root = new Node;\n    }\n\n    ~Trie()\n    {\n      delete root;\n    }\n\n    void add(string word)\n    {\n      //...\n    }\n\n    void search(string word)\n    {\n      //...\n    }\n\n  private:\n    Node* root;\n};</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>We have just one instance variable: a pointer to the root node of the trie. The constructor allocates memory for the root and the destructor deals with clearing it. The interesting stuff is in <code class=\"language-text\">add</code> and <code class=\"language-text\">search</code>.</p>\n<p><code class=\"language-text\">add</code> takes a string and iterates over its characters, adding new nodes along the way if it needs to, and setting the node it ends up at to final.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">void add(string word)\n{\n  Node* curr = root;\n  for(int i = 0;i &amp;lt; word.length();++i)\n  {\n    char&amp;amp; c = word[i];\n    if(!isalpha(c)) continue;\n    if(!curr-&amp;gt;child(c))\n      curr-&amp;gt;child(c) = new Node;\n    curr = curr-&amp;gt;child(c);\n  }\n  curr-&amp;gt;final = true;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">search</code> looks almost identical. We still iterate over the string, except now we just fail if we see a missing node, and, if that never happens, we check to see if the node we end up at is final.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">bool search(string word)\n{\n  Node* curr = root;\n  for(int i = 0;i &amp;lt; word.size();++i)\n  {\n    char&amp;amp; c = word[i];\n    if(!isalpha(c)) continue;\n    if(!curr-&amp;gt;child(c)) return false;\n    curr = curr-&amp;gt;child(c);\n  }\n  return curr-&amp;gt;final;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>And that’s it. Here’s the whole <code class=\"language-text\">Trie</code> class:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class Trie\n{\n  public:\n    struct Node\n    {\n      Node() : final(false)\n      {\n        for(int i = 0;i &amp;lt; 26;++i)\n          children[i] = 0;\n      }\n\n      ~Node()\n      {\n        for(int i = 0;i &amp;lt; 26;++i)\n          if(children[i]) delete children[i];\n      }\n\n      Node*&amp;amp; child(char c)\n      {\n        return children[tolower(c)-&#39;a&#39;];\n      }\n\n      Node* children[26];\n      bool final;\n    };\n\n    Trie()\n    {\n      root = new Node;\n    }\n\n    ~Trie()\n    {\n      delete root;\n    }\n\n    void add(string word)\n    {\n      Node* curr = root;\n      for(int i = 0;i &amp;lt; word.length();++i)\n      {\n        char&amp;amp; c = word[i];\n        if(!isalpha(c)) continue;\n        if(!curr-&amp;gt;child(c))\n          curr-&amp;gt;child(c) = new Node;\n        curr = curr-&amp;gt;child(c);\n      }\n      curr-&amp;gt;final = true;\n    }\n\n    bool search(string word)\n    {\n      Node* curr = root;\n      for(int i = 0;i &amp;lt; word.size();++i)\n      {\n        char&amp;amp; c = word[i];\n        if(!isalpha(c)) continue;\n        if(!curr-&amp;gt;child(c)) return false;\n        curr = curr-&amp;gt;child(c);\n      }\n      return curr-&amp;gt;final;\n    }\n  private:\n    Node* root;\n};</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4>A little command line interface</h4>\n<p>Now all that’s left to do is throw up a simple little interface to our program. We’ll have a simple command line interface with two commands: <code class=\"language-text\">add &amp;lt;word&amp;gt;</code>, and<code class=\"language-text\">search &amp;lt;word&amp;gt;</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">int main()\n{\n  Trie trie;\n  string tmp;\n\n  for(;;) //loop fo-evah (or until Ctrl+C)\n  {\n    cout &amp;lt;&amp;lt; &quot;&amp;gt; &quot;;\n    cin &amp;gt;&amp;gt; tmp;\n    if(tmp == &quot;add&quot;)\n    {\n      cin &amp;gt;&amp;gt; tmp;\n      trie.add(tmp);\n      cout &amp;lt;&amp;lt; &quot;added \\&quot;&quot; &amp;lt;&amp;lt; tmp &amp;lt;&amp;lt; &quot;\\&quot;&quot;;\n    }\n    else if(tmp == &quot;search&quot;)\n    {\n      cin &amp;gt;&amp;gt; tmp;\n      cout &amp;lt;&amp;lt; trie.search(tmp);\n    }\n    else\n      cerr &amp;lt;&amp;lt; &quot;unrecognized command&quot;;\n    cout &amp;lt;&amp;lt; endl;\n  }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>And that’s that. Compile your code (<code class=\"language-text\">g++ -o spell-check main.cpp</code> should work on UNIX) and fire her up.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">$ ./spell-check \n&amp;gt; search bob\n0\n&amp;gt; add bob\nadded &quot;bob&quot;\n&amp;gt; search bob\n1\n&amp;gt; add jacob\nadded &quot;jacob&quot;\n&amp;gt; search jacob\n1\n&amp;gt; search jaco\n0\n&amp;gt; search jacobb\n0</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4>Pre-filling the trie with a dictionary</h4>\n<p>Being able to index our own words is pretty cool, but really, we’d like to have our trie pre-packaged with words from a dictionary. Luckily, most UNIX systems have a dictionary file available that makes this really easy. For me, the file is <code class=\"language-text\">/usr/share/dict/words</code>. All you have to do is open that file with an <code class=\"language-text\">ifstream</code> and add all the words in it to our trie before we enter the command-line loop.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">cout &amp;lt;&amp;lt; &quot;indexing dictionary...&quot;;\nifstream dict(&quot;/usr/share/dict/words&quot;);\nwhile(!dict.eof())\n{\n  dict &amp;gt;&amp;gt; tmp;\n  trie.add(tmp);\n}\ncout &amp;lt;&amp;lt; &quot; done&quot; &amp;lt;&amp;lt; endl;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>And now just re-compile and run:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">$ ./spell-check \nindexing dictionary... done\n&amp;gt; search apple\n1\n&amp;gt; search hello\n1\n&amp;gt; search helo\n0\n&amp;gt; search helloo\n0</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Of course, we can still index our own words if we want:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">search helloo\n0\n&amp;gt; add helloo\nadded &quot;helloo&quot;\n&amp;gt; search helloo\n1</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Now we have our little spell-checker. Well, sort of.<em>Technically</em> what we’ve made is a spell-checker: it checks to see if you’ve spelled things right. What we really want though, is something that can recognize when we’ve spelled something wrong and also give us suggested corrections. This is when our trie will start becoming useful (after all, we could have done all this with a hash-table or other associative array as well, although our trie is most likely slightly more efficient).</p>\n<p>I’ll put out a part 2 soon, where I’ll cover actually generating the suggestions.</p>","excerpt":"Spell checking with tries in C++: Part 1 Tries are a really cool data structure used for storing strings (and potentially other things) efficiently and…","frontmatter":{"date":"04 November, 2013","path":"/blog/2013-11-04-trie-spell-checking-with-tries-in-c/","title":"[TRIE] Spell checking with tries in C++"},"fields":{"readingTime":{"text":"7 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}