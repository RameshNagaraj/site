{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2014-03-24-tree-inorder-successor-and-predecessor-of-a-bst-without-parent-pointer/","result":{"data":{"markdownRemark":{"html":"<p>Problem:<br>\nFind inorder successor/predecessor of given node in binary search tree.</p>\n<p>In-order successor of a node is the node which will come after the given node in in-order traversal of binary search tree. In other words, it would be the next larger element in BST.</p>\n<p>There are four cases:</p>\n<ol>\n<li>If there is a right child of the given node. In this case the smallest element in the right sub tree would be the in-order successor.  </li>\n<li>If node does not have right sub tree and if last turn was right, then the node where we took the last left turn will be the in-order successor.  </li>\n<li>If node does not have right sub tree and if last turn was left turn, parent of the node is inorder successor.  </li>\n<li>If the node is the right most node, then there is no in-order successor.</li>\n</ol>\n<p>It is clear from the analysis that we need to change the candidate only when we are moving towards left and not when moving right.</p>\n<p>Algorithm  </p>\n<ol>\n<li>Start with root.  </li>\n<li>If the node is given has less than root, then search on left side and update successor.  </li>\n<li>If the node is greater than root, then search in right part, don't update successor.  </li>\n<li>If we find the node and if the node has right sub tree, then the minimum node on the right sub tree of node is the in-order successor.  </li>\n<li>Return successor</li>\n</ol>\n<p>The Algorithm is divided into two cases on the basis of right subtree of the input node being empty or not.</p>\n<p>Input: node, root // node is the node whose Inorder successor is needed.<br>\noutput: succ // succ is Inorder successor of node.</p>\n<ol>\n<li>If right subtree of node is not NULL, then succ lies in right subtree. Do following.<br>\nGo to right subtree and return the node with minimum key value in right subtree.  </li>\n<li>If right sbtree of node is NULL, then start from root and us search like technique. Do following.<br>\nTravel down the tree, if a node’s data is greater than root’s data then go right side, otherwise go to left side.</li>\n</ol>\n<p>struct node * inOrderSuccessor(struct node *root, struct node *n)<br>\n{<br>\n// step 1 of the above algorithm<br>\nif( n->right != NULL )<br>\nreturn minValue(n->right);</p>\n<p> struct node *succ = NULL;</p>\n<p> // Start from root and search for successor down the tree<br>\nwhile (root != NULL)<br>\n{<br>\nif (n->data data)<br>\n{<br>\nsucc = root;<br>\nroot = root->left;<br>\n}<br>\nelse if (n->data > root->data)<br>\nroot = root->right;<br>\nelse<br>\nbreak;<br>\n}</p>\n<p> return succ;<br>\n}</p>\n<p>OR<br>\nNode * find_minimum(Node *root){<br>\nif(!root)<br>\nreturn NULL;</p>\n<p> while(root->left){<br>\nroot = root->left;</p>\n<p> }<br>\nreturn root;<br>\n}</p>\n<p>Node *inorder_success(Node *root, int K){</p>\n<p> Node * successor = NULL;<br>\nNode *current = root;<br>\nif(!root)<br>\nreturn NULL;</p>\n<p> while(current->value != K){<br>\nif(current->value >K){<br>\nsuccessor = current;<br>\ncurrent= current->left;<br>\n}<br>\nelse<br>\ncurrent = current->right;<br>\n}<br>\nif(current &#x26;&#x26; current->right){<br>\nsuccessor = find_minimum(current->right);<br>\n}</p>\n<p> return successor;<br>\n}</p>\n<p>Time Complexity: O(h) where h is height of tree.<br>\nComplexity of this algorithm will be O(logN) in almost balanced binary tree. If tree is skewed, then we have worst case complexity of O(N).</p>\n<p>Inorder Predecessor:<br>\nCase 1: Node has left sub tree.<br>\nIn this case the right most node in the left sub-tree would be the in-order predecessor.</p>\n<p>Case 2: Node has no left sub-tree.<br>\nIn this case in-order predecessor will be the node where we took the latest right turn.</p>\n<p>Case 3 : Node is left most node of BST.<br>\nThere is no in-order predecessor in this case and In this case there won't be any right turn.i.e. return NULL</p>\n<p>Node * find_maximum(Node *root){<br>\nif(!root)<br>\nreturn NULL;</p>\n<p> while(root->right){<br>\nroot = root->right;</p>\n<p> }<br>\nreturn root;<br>\n}</p>\n<p>Node *inorder_preced(Node *root, int K){</p>\n<p> Node * successor = NULL;<br>\nNode *current = root;<br>\nif(!root)<br>\nreturn NULL;</p>\n<p> while(current &#x26;&#x26; current->value != K){<br>\nif(current->value >K){<br>\ncurrent= current->left;<br>\n}<br>\nelse{<br>\nsuccessor = current;<br>\ncurrent = current->right;<br>\n}<br>\n}<br>\nif(current &#x26;&#x26; current->left){<br>\nsuccessor = find_maximum(current->left);<br>\n}</p>\n<p> return successor;</p>\n<p>}</p>\n<p>Complexity analysis<br>\nComplexity of finding in-order predecessor would be same as successor i.e. O(logN).</p>\n<p>PS<br>\nMethod 1 (Uses Parent Pointer)<br>\nIn this method, we assume that every node has parent pointer.</p>\n<p>The Algorithm is divided into two cases on the basis of right subtree of the input node being empty or not.</p>\n<p>Input: node, root // node is the node whose Inorder successor is needed.<br>\noutput: succ // succ is Inorder successor of node.</p>\n<ol>\n<li>If right subtree of node is not NULL, then succ lies in right subtree. Do following.<br>\nGo to right subtree and return the node with minimum key value in right subtree.  </li>\n<li>If right sbtree of node is NULL, then succ is one of the ancestors. Do following.<br>\nTravel up using the parent pointer until you see a node which is left child of it’s parent. The parent of such a node is the succ.</li>\n</ol>\n<p>Implementation<br>\nNote that the function to find InOrder Successor is highlighted (with gray background) in below code.</p>\n<p>#include<br>\n#include </p>\n<p>/* A binary tree node has data, pointer to left child<br>\nand a pointer to right child */<br>\nstruct node<br>\n{<br>\nint data;<br>\nstruct node* left;<br>\nstruct node* right;<br>\nstruct node* parent;<br>\n};</p>\n<p>struct node * minValue(struct node* node); </p>\n<p>struct node * inOrderSuccessor(struct node *root, struct node *n)<br>\n{<br>\n// step 1 of the above algorithm<br>\nif( n->right != NULL )<br>\nreturn minValue(n->right);</p>\n<p> // step 2 of the above algorithm<br>\nstruct node *p = n->parent;<br>\nwhile(p != NULL &#x26;&#x26; n == p->right)<br>\n{<br>\nn = p;<br>\np = p->parent;<br>\n}<br>\nreturn p;<br>\n}</p>\n<p>/* Given a non-empty binary search tree, return the minimum data<br>\nvalue found in that tree. Note that the entire tree does not need<br>\nto be searched. */<br>\nstruct node * minValue(struct node* node) {<br>\nstruct node* current = node;</p>\n<p> /* loop down to find the leftmost leaf */<br>\nwhile (current->left != NULL) {<br>\ncurrent = current->left;<br>\n}<br>\nreturn current;<br>\n}</p>\n<hr>\n<p>Here is a non-recursive version of finding the successor. There are two cases: (i) the right child of node is not NULL. In this case, we can find the successor by finding the minimum element of the right substree. (ii) If the right child of node is NULL, the successor must either be NULL, or the lowest node on the path from root to node whose value is larger than node's value.</p>\n<p>/*<br>\n* We assume that 'node' is in the tree<br>\n*/<br>\nNode * find_successor(Node * root, Node * node)<br>\n{<br>\nNode * y = root, * c = NULL;</p>\n<p> if (node->right != NULL){<br>\ny = node->right;<br>\nwhile (y->left != NULL) y = y->left;<br>\nreturn y;<br>\n}</p>\n<p> while ( y != node &#x26;&#x26; y != NULL ){<br>\nif ( node->data data ){<br>\nc = y;<br>\ny = y->left;<br>\n}<br>\nelse{<br>\ny = y->right;<br>\n}<br>\n}<br>\nreturn c;<br>\n}</p>\n<p>Node * find_predecessor(Node * root, Node * node)<br>\n{<br>\nNode * y = root, *c = NULL;<br>\nif (node->left != NULL){<br>\ny = node->left;<br>\nwhile (y->right != NULL) y = y->right;<br>\nreturn y;<br>\n}</p>\n<p> while ( y != node ){<br>\nif (node->data data){<br>\ny = y->left;<br>\n}<br>\nelse {<br>\nc = y;<br>\ny = y->right;<br>\n}<br>\n}<br>\nreturn c;<br>\n}</p>","excerpt":"Problem: Find inorder successor/predecessor of given node in binary search tree. In-order successor of a node is the node which will come after the given node…","frontmatter":{"date":"24 March, 2014","path":"/blog/2014-03-24-tree-inorder-successor-and-predecessor-of-a-bst-without-parent-pointer/","title":"[TREE] Inorder successor and predecessor of a BST without parent pointer"},"fields":{"readingTime":{"text":"6 min read"}}}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}